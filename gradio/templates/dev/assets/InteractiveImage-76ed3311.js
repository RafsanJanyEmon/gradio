import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, svg_element, attr_dev, add_location, insert_dev, append_dev, noop, detach_dev, createEventDispatcher, onMount, globals, element, space, toggle_class, transition_in, group_outros, transition_out, check_outros, binding_callbacks, listen_dev, is_function, create_component, mount_component, destroy_component, empty, flush, src_url_equal, ensure_array_like_dev, tick, onDestroy, add_render_callback, add_iframe_resize_listener, destroy_each, bubble, create_bidirectional_transition, set_style, stop_propagation, run_all, to_number, set_input_value, bind, add_flush_callback, create_slot, update_slot_base, get_all_dirty_from_scope, get_slot_changes, assign as assign$1, get_spread_update, get_spread_object } from './svelte/svelte-internal.js';
import { f as fade, n as normalise_file, B as Block } from './Button-153ea7e7.js';
import { B as BlockLabel } from './BlockLabel-6e86bddb.js';
import { S as Static } from './index-30423ace.js';
import { I as Image } from './Image-3675b397.js';
import { g as get_coordinates_of_clicked_image } from './utils-fe21d2ec.js';
import { I as IconButton } from './IconButton-a7cec4e3.js';
import { C as Clear, M as ModifyUpload } from './ModifyUpload-aa8b58d9.js';
import { U as Undo } from './Undo-863e44da.js';
import { U as Upload } from './Upload-3fd97bb0.js';
import { U as UploadText } from './UploadText-5bbd5d92.js';

/* Users/peterallen/Projects/gradio/js/icons/src/Brush.svelte generated by Svelte v4.0.0 */

const file$c = "Users/peterallen/Projects/gradio/js/icons/src/Brush.svelte";

function create_fragment$d(ctx) {
	let svg;
	let path0;
	let path1;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M28.828 3.172a4.094 4.094 0 0 0-5.656 0L4.05 22.292A6.954 6.954 0 0 0 2 27.242V30h2.756a6.952 6.952 0 0 0 4.95-2.05L28.828 8.829a3.999 3.999 0 0 0 0-5.657zM10.91 18.26l2.829 2.829l-2.122 2.121l-2.828-2.828zm-2.619 8.276A4.966 4.966 0 0 1 4.756 28H4v-.759a4.967 4.967 0 0 1 1.464-3.535l1.91-1.91l2.829 2.828zM27.415 7.414l-12.261 12.26l-2.829-2.828l12.262-12.26a2.047 2.047 0 0 1 2.828 0a2 2 0 0 1 0 2.828z");
			attr_dev(path0, "fill", "currentColor");
			add_location(path0, file$c, 1, 1, 54);
			attr_dev(path1, "d", "M6.5 15a3.5 3.5 0 0 1-2.475-5.974l3.5-3.5a1.502 1.502 0 0 0 0-2.121a1.537 1.537 0 0 0-2.121 0L3.415 5.394L2 3.98l1.99-1.988a3.585 3.585 0 0 1 4.95 0a3.504 3.504 0 0 1 0 4.949L5.439 10.44a1.502 1.502 0 0 0 0 2.121a1.537 1.537 0 0 0 2.122 0l4.024-4.024L13 9.95l-4.025 4.024A3.475 3.475 0 0 1 6.5 15z");
			attr_dev(path1, "fill", "currentColor");
			add_location(path1, file$c, 5, 1, 499);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$c, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Brush', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Brush> was created with unknown prop '${key}'`);
	});

	return [];
}

class Brush extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Brush",
			options,
			id: create_fragment$d.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Camera.svelte generated by Svelte v4.0.0 */

const file$b = "Users/peterallen/Projects/gradio/js/icons/src/Camera.svelte";

function create_fragment$c(ctx) {
	let svg;
	let path;
	let circle;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
			add_location(path, file$b, 12, 1, 231);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "13");
			attr_dev(circle, "r", "4");
			add_location(circle, file$b, 15, 1, 330);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", "1.5");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "feather feather-camera");
			add_location(svg, file$b, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Camera', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Camera> was created with unknown prop '${key}'`);
	});

	return [];
}

class Camera extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Camera",
			options,
			id: create_fragment$c.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Circle.svelte generated by Svelte v4.0.0 */

const file$a = "Users/peterallen/Projects/gradio/js/icons/src/Circle.svelte";

function create_fragment$b(ctx) {
	let svg;
	let circle;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$a, 12, 1, 221);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "red");
			attr_dev(svg, "stroke", "red");
			attr_dev(svg, "stroke-width", "1.5");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "feather feather-circle");
			add_location(svg, file$a, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Circle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Circle> was created with unknown prop '${key}'`);
	});

	return [];
}

class Circle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Circle",
			options,
			id: create_fragment$b.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Color.svelte generated by Svelte v4.0.0 */

const file$9 = "Users/peterallen/Projects/gradio/js/icons/src/Color.svelte";

function create_fragment$a(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let circle3;
	let circle4;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			circle3 = svg_element("circle");
			circle4 = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle0, "cx", "10");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "2");
			attr_dev(circle0, "fill", "currentColor");
			add_location(circle0, file$9, 1, 1, 54);
			attr_dev(circle1, "cx", "16");
			attr_dev(circle1, "cy", "9");
			attr_dev(circle1, "r", "2");
			attr_dev(circle1, "fill", "currentColor");
			add_location(circle1, file$9, 2, 1, 108);
			attr_dev(circle2, "cx", "22");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "2");
			attr_dev(circle2, "fill", "currentColor");
			add_location(circle2, file$9, 3, 1, 161);
			attr_dev(circle3, "cx", "23");
			attr_dev(circle3, "cy", "18");
			attr_dev(circle3, "r", "2");
			attr_dev(circle3, "fill", "currentColor");
			add_location(circle3, file$9, 4, 1, 215);
			attr_dev(circle4, "cx", "19");
			attr_dev(circle4, "cy", "23");
			attr_dev(circle4, "r", "2");
			attr_dev(circle4, "fill", "currentColor");
			add_location(circle4, file$9, 5, 1, 269);
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M16.54 2A14 14 0 0 0 2 16a4.82 4.82 0 0 0 6.09 4.65l1.12-.31a3 3 0 0 1 3.79 2.9V27a3 3 0 0 0 3 3a14 14 0 0 0 14-14.54A14.05 14.05 0 0 0 16.54 2Zm8.11 22.31A11.93 11.93 0 0 1 16 28a1 1 0 0 1-1-1v-3.76a5 5 0 0 0-5-5a5.07 5.07 0 0 0-1.33.18l-1.12.31A2.82 2.82 0 0 1 4 16A12 12 0 0 1 16.47 4A12.18 12.18 0 0 1 28 15.53a11.89 11.89 0 0 1-3.35 8.79Z");
			add_location(path, file$9, 6, 1, 323);
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$9, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, circle2);
			append_dev(svg, circle3);
			append_dev(svg, circle4);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Color', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Color> was created with unknown prop '${key}'`);
	});

	return [];
}

class Color extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Color",
			options,
			id: create_fragment$a.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Erase.svelte generated by Svelte v4.0.0 */

const file$8 = "Users/peterallen/Projects/gradio/js/icons/src/Erase.svelte";

function create_fragment$9(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M7 27h23v2H7zm20.38-16.49l-7.93-7.92a2 2 0 0 0-2.83 0l-14 14a2 2 0 0 0 0 2.83L7.13 24h9.59l10.66-10.66a2 2 0 0 0 0-2.83zM15.89 22H8l-4-4l6.31-6.31l7.93 7.92zm3.76-3.76l-7.92-7.93L18 4l8 7.93z");
			add_location(path, file$8, 5, 2, 93);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 32 32");
			add_location(svg, file$8, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Erase', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Erase> was created with unknown prop '${key}'`);
	});

	return [];
}

class Erase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Erase",
			options,
			id: create_fragment$9.name
		});
	}
}

/* Users/peterallen/Projects/gradio/js/icons/src/Sketch.svelte generated by Svelte v4.0.0 */

const file$7 = "Users/peterallen/Projects/gradio/js/icons/src/Sketch.svelte";

function create_fragment$8(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
			add_location(path, file$7, 12, 1, 231);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "stroke-width", "1.5");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "feather feather-edit-2");
			add_location(svg, file$7, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sketch', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sketch> was created with unknown prop '${key}'`);
	});

	return [];
}

let Sketch$1 = class Sketch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sketch",
			options,
			id: create_fragment$8.name
		});
	}
};

/* Users/peterallen/Projects/gradio/js/icons/src/Square.svelte generated by Svelte v4.0.0 */

const file$6 = "Users/peterallen/Projects/gradio/js/icons/src/Square.svelte";

function create_fragment$7(ctx) {
	let svg;
	let rect;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$6, 12, 1, 221);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", "100%");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "red");
			attr_dev(svg, "stroke", "red");
			attr_dev(svg, "stroke-width", "1.5");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "feather feather-square");
			add_location(svg, file$6, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Square', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Square> was created with unknown prop '${key}'`);
	});

	return [];
}

class Square extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Square",
			options,
			id: create_fragment$7.name
		});
	}
}

const Webcam_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/image/interactive/Webcam.svelte generated by Svelte v4.0.0 */

const { console: console_1$1 } = globals;
const file$5 = "Users/peterallen/Projects/gradio/js/image/interactive/Webcam.svelte";

// (102:1) {#if !streaming}
function create_if_block$4(ctx) {
	let button;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$2, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[1] === "video") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			button = element("button");
			if_block.c();
			attr_dev(button, "class", "s-jffn1zpwty1n");
			add_location(button, file$5, 132, 2, 3184);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if_blocks[current_block_type_index].m(button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					button,
					"click",
					function () {
						if (is_function(/*mode*/ ctx[1] === "image"
						? /*take_picture*/ ctx[5]
						: /*take_recording*/ ctx[6])) (/*mode*/ ctx[1] === "image"
						? /*take_picture*/ ctx[5]
						: /*take_recording*/ ctx[6]).apply(this, arguments);
					},
					false,
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(button, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(102:1) {#if !streaming}",
		ctx
	});

	return block;
}

// (114:3) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let camera;
	let current;
	camera = new Camera({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(camera.$$.fragment);
			attr_dev(div, "class", "icon s-jffn1zpwty1n");
			add_location(div, file$5, 144, 4, 3442);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(camera, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(camera.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(camera.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(camera);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(114:3) {:else}",
		ctx
	});

	return block;
}

// (104:3) {#if mode === "video"}
function create_if_block_1$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$2, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*recording*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(104:3) {#if mode === \\\"video\\\"}",
		ctx
	});

	return block;
}

// (109:4) {:else}
function create_else_block$1(ctx) {
	let div;
	let circle;
	let current;
	circle = new Circle({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(circle.$$.fragment);
			attr_dev(div, "class", "icon s-jffn1zpwty1n");
			add_location(div, file$5, 139, 5, 3369);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(circle, div, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(circle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(circle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(109:4) {:else}",
		ctx
	});

	return block;
}

// (105:4) {#if recording}
function create_if_block_2$2(ctx) {
	let div;
	let square;
	let current;
	square = new Square({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(square.$$.fragment);
			attr_dev(div, "class", "icon s-jffn1zpwty1n");
			add_location(div, file$5, 135, 5, 3304);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(square, div, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(square.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(square.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(square);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(105:4) {#if recording}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div;
	let video;
	let t;
	let current;
	let if_block = !/*streaming*/ ctx[0] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div = element("div");
			video = element("video");
			t = space();
			if (if_block) if_block.c();
			attr_dev(video, "class", "s-jffn1zpwty1n");
			toggle_class(video, "flip", /*mirror_webcam*/ ctx[2]);
			add_location(video, file$5, 130, 1, 3102);
			attr_dev(div, "class", "wrap s-jffn1zpwty1n");
			add_location(div, file$5, 128, 0, 3035);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, video);
			/*video_binding*/ ctx[10](video);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*mirror_webcam*/ 4) {
				toggle_class(video, "flip", /*mirror_webcam*/ ctx[2]);
			}

			if (!/*streaming*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*streaming*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			/*video_binding*/ ctx[10](null);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Webcam', slots, []);
	let video_source;
	let canvas;
	let { streaming = false } = $$props;
	let { pending = false } = $$props;
	let { mode = "image" } = $$props;
	let { mirror_webcam } = $$props;
	let { include_audio } = $$props;
	let { i18n } = $$props;
	const dispatch = createEventDispatcher();
	onMount(() => canvas = document.createElement("canvas"));

	async function access_webcam() {
		try {
			stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: include_audio });
			$$invalidate(3, video_source.srcObject = stream, video_source);
			$$invalidate(3, video_source.muted = true, video_source);
			video_source.play();
		} catch(err) {
			if (err instanceof DOMException && err.name == "NotAllowedError") {
				dispatch("error", i18n("image.allow_webcam_access"));
			} else {
				throw err;
			}
		}
	}

	function take_picture() {
		var context = canvas.getContext("2d");

		if (video_source.videoWidth && video_source.videoHeight) {
			canvas.width = video_source.videoWidth;
			canvas.height = video_source.videoHeight;
			context.drawImage(video_source, 0, 0, video_source.videoWidth, video_source.videoHeight);
			var data = canvas.toDataURL("image/png");
			dispatch(streaming ? "stream" : "capture", data);
		}
	}

	let recording = false;
	let recorded_blobs = [];
	let stream;
	let mimeType;
	let media_recorder;

	function take_recording() {
		if (recording) {
			media_recorder.stop();
			let video_blob = new Blob(recorded_blobs, { type: mimeType });
			let ReaderObj = new FileReader();

			ReaderObj.onload = function (e) {
				if (e.target) {
					dispatch("capture", {
						data: e.target.result,
						name: "sample." + mimeType.substring(6),
						is_example: false,
						is_file: false
					});

					dispatch("stop_recording");
				}
			};

			ReaderObj.readAsDataURL(video_blob);
		} else {
			dispatch("start_recording");
			recorded_blobs = [];
			let validMimeTypes = ["video/webm", "video/mp4"];

			for (let validMimeType of validMimeTypes) {
				if (MediaRecorder.isTypeSupported(validMimeType)) {
					mimeType = validMimeType;
					break;
				}
			}

			if (mimeType === null) {
				console.error("No supported MediaRecorder mimeType");
				return;
			}

			media_recorder = new MediaRecorder(stream, { mimeType });

			media_recorder.addEventListener("dataavailable", function (e) {
				recorded_blobs.push(e.data);
			});

			media_recorder.start(200);
		}

		$$invalidate(4, recording = !recording);
	}

	access_webcam();

	if (streaming && mode === "image") {
		window.setInterval(
			() => {
				if (video_source && !pending) {
					take_picture();
				}
			},
			500
		);
	}

	$$self.$$.on_mount.push(function () {
		if (mirror_webcam === undefined && !('mirror_webcam' in $$props || $$self.$$.bound[$$self.$$.props['mirror_webcam']])) {
			console_1$1.warn("<Webcam> was created without expected prop 'mirror_webcam'");
		}

		if (include_audio === undefined && !('include_audio' in $$props || $$self.$$.bound[$$self.$$.props['include_audio']])) {
			console_1$1.warn("<Webcam> was created without expected prop 'include_audio'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console_1$1.warn("<Webcam> was created without expected prop 'i18n'");
		}
	});

	const writable_props = ['streaming', 'pending', 'mode', 'mirror_webcam', 'include_audio', 'i18n'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Webcam> was created with unknown prop '${key}'`);
	});

	function video_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			video_source = $$value;
			$$invalidate(3, video_source);
		});
	}

	$$self.$$set = $$props => {
		if ('streaming' in $$props) $$invalidate(0, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(7, pending = $$props.pending);
		if ('mode' in $$props) $$invalidate(1, mode = $$props.mode);
		if ('mirror_webcam' in $$props) $$invalidate(2, mirror_webcam = $$props.mirror_webcam);
		if ('include_audio' in $$props) $$invalidate(8, include_audio = $$props.include_audio);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		Camera,
		Circle,
		Square,
		video_source,
		canvas,
		streaming,
		pending,
		mode,
		mirror_webcam,
		include_audio,
		i18n,
		dispatch,
		access_webcam,
		take_picture,
		recording,
		recorded_blobs,
		stream,
		mimeType,
		media_recorder,
		take_recording
	});

	$$self.$inject_state = $$props => {
		if ('video_source' in $$props) $$invalidate(3, video_source = $$props.video_source);
		if ('canvas' in $$props) canvas = $$props.canvas;
		if ('streaming' in $$props) $$invalidate(0, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(7, pending = $$props.pending);
		if ('mode' in $$props) $$invalidate(1, mode = $$props.mode);
		if ('mirror_webcam' in $$props) $$invalidate(2, mirror_webcam = $$props.mirror_webcam);
		if ('include_audio' in $$props) $$invalidate(8, include_audio = $$props.include_audio);
		if ('i18n' in $$props) $$invalidate(9, i18n = $$props.i18n);
		if ('recording' in $$props) $$invalidate(4, recording = $$props.recording);
		if ('recorded_blobs' in $$props) recorded_blobs = $$props.recorded_blobs;
		if ('stream' in $$props) stream = $$props.stream;
		if ('mimeType' in $$props) mimeType = $$props.mimeType;
		if ('media_recorder' in $$props) media_recorder = $$props.media_recorder;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		streaming,
		mode,
		mirror_webcam,
		video_source,
		recording,
		take_picture,
		take_recording,
		pending,
		include_audio,
		i18n,
		video_binding
	];
}

class Webcam extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			streaming: 0,
			pending: 7,
			mode: 1,
			mirror_webcam: 2,
			include_audio: 8,
			i18n: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Webcam",
			options,
			id: create_fragment$6.name
		});
	}

	get streaming() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streaming(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pending() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pending(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mirror_webcam() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mirror_webcam(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get include_audio() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set include_audio(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<Webcam>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<Webcam>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const Webcam$1 = Webcam;

/*!
 * Cropper.js v1.5.12
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2021-06-12T08:00:17.411Z
 */

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
var WINDOW = IS_BROWSER ? window : {};
var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
var NAMESPACE = 'cropper'; // Actions

var ACTION_ALL = 'all';
var ACTION_CROP = 'crop';
var ACTION_MOVE = 'move';
var ACTION_ZOOM = 'zoom';
var ACTION_EAST = 'e';
var ACTION_WEST = 'w';
var ACTION_SOUTH = 's';
var ACTION_NORTH = 'n';
var ACTION_NORTH_EAST = 'ne';
var ACTION_NORTH_WEST = 'nw';
var ACTION_SOUTH_EAST = 'se';
var ACTION_SOUTH_WEST = 'sw'; // Classes

var CLASS_CROP = "".concat(NAMESPACE, "-crop");
var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

var DATA_ACTION = "".concat(NAMESPACE, "Action");
var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

var DRAG_MODE_CROP = 'crop';
var DRAG_MODE_MOVE = 'move';
var DRAG_MODE_NONE = 'none'; // Events

var EVENT_CROP = 'crop';
var EVENT_CROP_END = 'cropend';
var EVENT_CROP_MOVE = 'cropmove';
var EVENT_CROP_START = 'cropstart';
var EVENT_DBLCLICK = 'dblclick';
var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
var EVENT_READY = 'ready';
var EVENT_RESIZE = 'resize';
var EVENT_WHEEL = 'wheel';
var EVENT_ZOOM = 'zoom'; // Mime types

var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
var REGEXP_DATA_URL = /^data:/;
var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc
// Inspired by the default width and height of a canvas element.

var MIN_CONTAINER_WIDTH = 200;
var MIN_CONTAINER_HEIGHT = 100;

var DEFAULTS = {
  // Define the view mode of the cropper
  viewMode: 0,
  // 0, 1, 2, 3
  // Define the dragging mode of the cropper
  dragMode: DRAG_MODE_CROP,
  // 'crop', 'move' or 'none'
  // Define the initial aspect ratio of the crop box
  initialAspectRatio: NaN,
  // Define the aspect ratio of the crop box
  aspectRatio: NaN,
  // An object with the previous cropping result data
  data: null,
  // A selector for adding extra containers to preview
  preview: '',
  // Re-render the cropper when resize the window
  responsive: true,
  // Restore the cropped area after resize the window
  restore: true,
  // Check if the current image is a cross-origin image
  checkCrossOrigin: true,
  // Check the current image's Exif Orientation information
  checkOrientation: true,
  // Show the black modal
  modal: true,
  // Show the dashed lines for guiding
  guides: true,
  // Show the center indicator for guiding
  center: true,
  // Show the white modal to highlight the crop box
  highlight: true,
  // Show the grid background
  background: true,
  // Enable to crop the image automatically when initialize
  autoCrop: true,
  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,
  // Enable to move the image
  movable: true,
  // Enable to rotate the image
  rotatable: true,
  // Enable to scale the image
  scalable: true,
  // Enable to zoom the image
  zoomable: true,
  // Enable to zoom the image by dragging touch
  zoomOnTouch: true,
  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: true,
  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,
  // Enable to move the crop box
  cropBoxMovable: true,
  // Enable to resize the crop box
  cropBoxResizable: true,
  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: true,
  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: MIN_CONTAINER_WIDTH,
  minContainerHeight: MIN_CONTAINER_HEIGHT,
  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
};

var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

/**
 * Check if the given value is not a number.
 */

var isNaN = Number.isNaN || WINDOW.isNaN;
/**
 * Check if the given value is a number.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a number, else `false`.
 */

function isNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}
/**
 * Check if the given value is a positive number.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
 */

var isPositiveNumber = function isPositiveNumber(value) {
  return value > 0 && value < Infinity;
};
/**
 * Check if the given value is undefined.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
 */

function isUndefined(value) {
  return typeof value === 'undefined';
}
/**
 * Check if the given value is an object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is an object, else `false`.
 */

function isObject(value) {
  return _typeof(value) === 'object' && value !== null;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Check if the given value is a plain object.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
 */

function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }

  try {
    var _constructor = value.constructor;
    var prototype = _constructor.prototype;
    return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
  } catch (error) {
    return false;
  }
}
/**
 * Check if the given value is a function.
 * @param {*} value - The value to check.
 * @returns {boolean} Returns `true` if the given value is a function, else `false`.
 */

function isFunction(value) {
  return typeof value === 'function';
}
var slice = Array.prototype.slice;
/**
 * Convert array-like or iterable object to an array.
 * @param {*} value - The value to convert.
 * @returns {Array} Returns a new array.
 */

function toArray(value) {
  return Array.from ? Array.from(value) : slice.call(value);
}
/**
 * Iterate the given data.
 * @param {*} data - The data to iterate.
 * @param {Function} callback - The process function for each element.
 * @returns {*} The original data.
 */

function forEach(data, callback) {
  if (data && isFunction(callback)) {
    if (Array.isArray(data) || isNumber(data.length)
    /* array-like */
    ) {
        toArray(data).forEach(function (value, key) {
          callback.call(data, value, key, data);
        });
      } else if (isObject(data)) {
      Object.keys(data).forEach(function (key) {
        callback.call(data, data[key], key, data);
      });
    }
  }

  return data;
}
/**
 * Extend the given object.
 * @param {*} target - The target object to extend.
 * @param {*} args - The rest objects for merging to the target object.
 * @returns {Object} The extended object.
 */

var assign = Object.assign || function assign(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (isObject(target) && args.length > 0) {
    args.forEach(function (arg) {
      if (isObject(arg)) {
        Object.keys(arg).forEach(function (key) {
          target[key] = arg[key];
        });
      }
    });
  }

  return target;
};
var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
/**
 * Normalize decimal number.
 * Check out {@link https://0.30000000000000004.com/}
 * @param {number} value - The value to normalize.
 * @param {number} [times=100000000000] - The times for normalizing.
 * @returns {number} Returns the normalized number.
 */

function normalizeDecimalNumber(value) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
}
var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
/**
 * Apply styles to the given element.
 * @param {Element} element - The target element.
 * @param {Object} styles - The styles for applying.
 */

function setStyle(element, styles) {
  var style = element.style;
  forEach(styles, function (value, property) {
    if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
      value = "".concat(value, "px");
    }

    style[property] = value;
  });
}
/**
 * Check if the given element has a special class.
 * @param {Element} element - The element to check.
 * @param {string} value - The class to search.
 * @returns {boolean} Returns `true` if the special class was found.
 */

function hasClass(element, value) {
  return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
}
/**
 * Add classes to the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be added.
 */

function addClass(element, value) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    forEach(element, function (elem) {
      addClass(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.add(value);
    return;
  }

  var className = element.className.trim();

  if (!className) {
    element.className = value;
  } else if (className.indexOf(value) < 0) {
    element.className = "".concat(className, " ").concat(value);
  }
}
/**
 * Remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be removed.
 */

function removeClass(element, value) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    forEach(element, function (elem) {
      removeClass(elem, value);
    });
    return;
  }

  if (element.classList) {
    element.classList.remove(value);
    return;
  }

  if (element.className.indexOf(value) >= 0) {
    element.className = element.className.replace(value, '');
  }
}
/**
 * Add or remove classes from the given element.
 * @param {Element} element - The target element.
 * @param {string} value - The classes to be toggled.
 * @param {boolean} added - Add only.
 */

function toggleClass(element, value, added) {
  if (!value) {
    return;
  }

  if (isNumber(element.length)) {
    forEach(element, function (elem) {
      toggleClass(elem, value, added);
    });
    return;
  } // IE10-11 doesn't support the second parameter of `classList.toggle`


  if (added) {
    addClass(element, value);
  } else {
    removeClass(element, value);
  }
}
var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
/**
 * Transform the given string from camelCase to kebab-case
 * @param {string} value - The value to transform.
 * @returns {string} The transformed value.
 */

function toParamCase(value) {
  return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
}
/**
 * Get data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to get.
 * @returns {string} The data value.
 */

function getData(element, name) {
  if (isObject(element[name])) {
    return element[name];
  }

  if (element.dataset) {
    return element.dataset[name];
  }

  return element.getAttribute("data-".concat(toParamCase(name)));
}
/**
 * Set data to the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to set.
 * @param {string} data - The data value.
 */

function setData(element, name, data) {
  if (isObject(data)) {
    element[name] = data;
  } else if (element.dataset) {
    element.dataset[name] = data;
  } else {
    element.setAttribute("data-".concat(toParamCase(name)), data);
  }
}
/**
 * Remove data from the given element.
 * @param {Element} element - The target element.
 * @param {string} name - The data key to remove.
 */

function removeData(element, name) {
  if (isObject(element[name])) {
    try {
      delete element[name];
    } catch (error) {
      element[name] = undefined;
    }
  } else if (element.dataset) {
    // #128 Safari not allows to delete dataset property
    try {
      delete element.dataset[name];
    } catch (error) {
      element.dataset[name] = undefined;
    }
  } else {
    element.removeAttribute("data-".concat(toParamCase(name)));
  }
}
var REGEXP_SPACES = /\s\s*/;

var onceSupported = function () {
  var supported = false;

  if (IS_BROWSER) {
    var once = false;

    var listener = function listener() {};

    var options = Object.defineProperty({}, 'once', {
      get: function get() {
        supported = true;
        return once;
      },

      /**
       * This setter can fix a `TypeError` in strict mode
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
       * @param {boolean} value - The value to set
       */
      set: function set(value) {
        once = value;
      }
    });
    WINDOW.addEventListener('test', listener, options);
    WINDOW.removeEventListener('test', listener, options);
  }

  return supported;
}();
/**
 * Remove event listener from the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Function} listener - The event listener.
 * @param {Object} options - The event options.
 */


function removeListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function (event) {
    if (!onceSupported) {
      var listeners = element.listeners;

      if (listeners && listeners[event] && listeners[event][listener]) {
        handler = listeners[event][listener];
        delete listeners[event][listener];

        if (Object.keys(listeners[event]).length === 0) {
          delete listeners[event];
        }

        if (Object.keys(listeners).length === 0) {
          delete element.listeners;
        }
      }
    }

    element.removeEventListener(event, handler, options);
  });
}
/**
 * Add event listener to the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Function} listener - The event listener.
 * @param {Object} options - The event options.
 */

function addListener(element, type, listener) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _handler = listener;
  type.trim().split(REGEXP_SPACES).forEach(function (event) {
    if (options.once && !onceSupported) {
      var _element$listeners = element.listeners,
          listeners = _element$listeners === void 0 ? {} : _element$listeners;

      _handler = function handler() {
        delete listeners[event][listener];
        element.removeEventListener(event, _handler, options);

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        listener.apply(element, args);
      };

      if (!listeners[event]) {
        listeners[event] = {};
      }

      if (listeners[event][listener]) {
        element.removeEventListener(event, listeners[event][listener], options);
      }

      listeners[event][listener] = _handler;
      element.listeners = listeners;
    }

    element.addEventListener(event, _handler, options);
  });
}
/**
 * Dispatch event on the target element.
 * @param {Element} element - The event target.
 * @param {string} type - The event type(s).
 * @param {Object} data - The additional event data.
 * @returns {boolean} Indicate if the event is default prevented or not.
 */

function dispatchEvent(element, type, data) {
  var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

  if (isFunction(Event) && isFunction(CustomEvent)) {
    event = new CustomEvent(type, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, data);
  }

  return element.dispatchEvent(event);
}
/**
 * Get the offset base on the document.
 * @param {Element} element - The target element.
 * @returns {Object} The offset data.
 */

function getOffset(element) {
  var box = element.getBoundingClientRect();
  return {
    left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: box.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
var location = WINDOW.location;
var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
/**
 * Check if the given URL is a cross origin URL.
 * @param {string} url - The target URL.
 * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
 */

function isCrossOriginURL(url) {
  var parts = url.match(REGEXP_ORIGINS);
  return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
}
/**
 * Add timestamp to the given URL.
 * @param {string} url - The target URL.
 * @returns {string} The result URL.
 */

function addTimestamp(url) {
  var timestamp = "timestamp=".concat(new Date().getTime());
  return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
}
/**
 * Get transforms base on the given object.
 * @param {Object} obj - The target object.
 * @returns {string} A string contains transform values.
 */

function getTransforms(_ref) {
  var rotate = _ref.rotate,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      translateX = _ref.translateX,
      translateY = _ref.translateY;
  var values = [];

  if (isNumber(translateX) && translateX !== 0) {
    values.push("translateX(".concat(translateX, "px)"));
  }

  if (isNumber(translateY) && translateY !== 0) {
    values.push("translateY(".concat(translateY, "px)"));
  } // Rotate should come first before scale to match orientation transform


  if (isNumber(rotate) && rotate !== 0) {
    values.push("rotate(".concat(rotate, "deg)"));
  }

  if (isNumber(scaleX) && scaleX !== 1) {
    values.push("scaleX(".concat(scaleX, ")"));
  }

  if (isNumber(scaleY) && scaleY !== 1) {
    values.push("scaleY(".concat(scaleY, ")"));
  }

  var transform = values.length ? values.join(' ') : 'none';
  return {
    WebkitTransform: transform,
    msTransform: transform,
    transform: transform
  };
}
/**
 * Get the max ratio of a group of pointers.
 * @param {string} pointers - The target pointers.
 * @returns {number} The result ratio.
 */

function getMaxZoomRatio(pointers) {
  var pointers2 = _objectSpread2({}, pointers);

  var maxRatio = 0;
  forEach(pointers, function (pointer, pointerId) {
    delete pointers2[pointerId];
    forEach(pointers2, function (pointer2) {
      var x1 = Math.abs(pointer.startX - pointer2.startX);
      var y1 = Math.abs(pointer.startY - pointer2.startY);
      var x2 = Math.abs(pointer.endX - pointer2.endX);
      var y2 = Math.abs(pointer.endY - pointer2.endY);
      var z1 = Math.sqrt(x1 * x1 + y1 * y1);
      var z2 = Math.sqrt(x2 * x2 + y2 * y2);
      var ratio = (z2 - z1) / z1;

      if (Math.abs(ratio) > Math.abs(maxRatio)) {
        maxRatio = ratio;
      }
    });
  });
  return maxRatio;
}
/**
 * Get a pointer from an event object.
 * @param {Object} event - The target event object.
 * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
 * @returns {Object} The result pointer contains start and/or end point coordinates.
 */

function getPointer(_ref2, endOnly) {
  var pageX = _ref2.pageX,
      pageY = _ref2.pageY;
  var end = {
    endX: pageX,
    endY: pageY
  };
  return endOnly ? end : _objectSpread2({
    startX: pageX,
    startY: pageY
  }, end);
}
/**
 * Get the center point coordinate of a group of pointers.
 * @param {Object} pointers - The target pointers.
 * @returns {Object} The center point coordinate.
 */

function getPointersCenter(pointers) {
  var pageX = 0;
  var pageY = 0;
  var count = 0;
  forEach(pointers, function (_ref3) {
    var startX = _ref3.startX,
        startY = _ref3.startY;
    pageX += startX;
    pageY += startY;
    count += 1;
  });
  pageX /= count;
  pageY /= count;
  return {
    pageX: pageX,
    pageY: pageY
  };
}
/**
 * Get the max sizes in a rectangle under the given aspect ratio.
 * @param {Object} data - The original sizes.
 * @param {string} [type='contain'] - The adjust type.
 * @returns {Object} The result sizes.
 */

function getAdjustedSizes(_ref4) // or 'cover'
{
  var aspectRatio = _ref4.aspectRatio,
      height = _ref4.height,
      width = _ref4.width;
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
  var isValidWidth = isPositiveNumber(width);
  var isValidHeight = isPositiveNumber(height);

  if (isValidWidth && isValidHeight) {
    var adjustedWidth = height * aspectRatio;

    if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
      height = width / aspectRatio;
    } else {
      width = height * aspectRatio;
    }
  } else if (isValidWidth) {
    height = width / aspectRatio;
  } else if (isValidHeight) {
    width = height * aspectRatio;
  }

  return {
    width: width,
    height: height
  };
}
/**
 * Get the new sizes of a rectangle after rotated.
 * @param {Object} data - The original sizes.
 * @returns {Object} The result sizes.
 */

function getRotatedSizes(_ref5) {
  var width = _ref5.width,
      height = _ref5.height,
      degree = _ref5.degree;
  degree = Math.abs(degree) % 180;

  if (degree === 90) {
    return {
      width: height,
      height: width
    };
  }

  var arc = degree % 90 * Math.PI / 180;
  var sinArc = Math.sin(arc);
  var cosArc = Math.cos(arc);
  var newWidth = width * cosArc + height * sinArc;
  var newHeight = width * sinArc + height * cosArc;
  return degree > 90 ? {
    width: newHeight,
    height: newWidth
  } : {
    width: newWidth,
    height: newHeight
  };
}
/**
 * Get a canvas which drew the given image.
 * @param {HTMLImageElement} image - The image for drawing.
 * @param {Object} imageData - The image data.
 * @param {Object} canvasData - The canvas data.
 * @param {Object} options - The options.
 * @returns {HTMLCanvasElement} The result canvas.
 */

function getSourceCanvas(image, _ref6, _ref7, _ref8) {
  var imageAspectRatio = _ref6.aspectRatio,
      imageNaturalWidth = _ref6.naturalWidth,
      imageNaturalHeight = _ref6.naturalHeight,
      _ref6$rotate = _ref6.rotate,
      rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
      _ref6$scaleX = _ref6.scaleX,
      scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
      _ref6$scaleY = _ref6.scaleY,
      scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
  var aspectRatio = _ref7.aspectRatio,
      naturalWidth = _ref7.naturalWidth,
      naturalHeight = _ref7.naturalHeight;
  var _ref8$fillColor = _ref8.fillColor,
      fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
      _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
      imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
      _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
      imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
      _ref8$maxWidth = _ref8.maxWidth,
      maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
      _ref8$maxHeight = _ref8.maxHeight,
      maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
      _ref8$minWidth = _ref8.minWidth,
      minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
      _ref8$minHeight = _ref8.minHeight,
      minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  var maxSizes = getAdjustedSizes({
    aspectRatio: aspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var minSizes = getAdjustedSizes({
    aspectRatio: aspectRatio,
    width: minWidth,
    height: minHeight
  }, 'cover');
  var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
  var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
  // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

  var destMaxSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: maxWidth,
    height: maxHeight
  });
  var destMinSizes = getAdjustedSizes({
    aspectRatio: imageAspectRatio,
    width: minWidth,
    height: minHeight
  }, 'cover');
  var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
  var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
  var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
  canvas.width = normalizeDecimalNumber(width);
  canvas.height = normalizeDecimalNumber(height);
  context.fillStyle = fillColor;
  context.fillRect(0, 0, width, height);
  context.save();
  context.translate(width / 2, height / 2);
  context.rotate(rotate * Math.PI / 180);
  context.scale(scaleX, scaleY);
  context.imageSmoothingEnabled = imageSmoothingEnabled;
  context.imageSmoothingQuality = imageSmoothingQuality;
  context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
    return Math.floor(normalizeDecimalNumber(param));
  }))));
  context.restore();
  return canvas;
}
var fromCharCode = String.fromCharCode;
/**
 * Get string from char code in data view.
 * @param {DataView} dataView - The data view for read.
 * @param {number} start - The start index.
 * @param {number} length - The read length.
 * @returns {string} The read result.
 */

function getStringFromCharCode(dataView, start, length) {
  var str = '';
  length += start;

  for (var i = start; i < length; i += 1) {
    str += fromCharCode(dataView.getUint8(i));
  }

  return str;
}
var REGEXP_DATA_URL_HEAD = /^data:.*,/;
/**
 * Transform Data URL to array buffer.
 * @param {string} dataURL - The Data URL to transform.
 * @returns {ArrayBuffer} The result array buffer.
 */

function dataURLToArrayBuffer(dataURL) {
  var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
  var binary = atob(base64);
  var arrayBuffer = new ArrayBuffer(binary.length);
  var uint8 = new Uint8Array(arrayBuffer);
  forEach(uint8, function (value, i) {
    uint8[i] = binary.charCodeAt(i);
  });
  return arrayBuffer;
}
/**
 * Transform array buffer to Data URL.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
 * @param {string} mimeType - The mime type of the Data URL.
 * @returns {string} The result Data URL.
 */

function arrayBufferToDataURL(arrayBuffer, mimeType) {
  var chunks = []; // Chunk Typed Array for better performance (#435)

  var chunkSize = 8192;
  var uint8 = new Uint8Array(arrayBuffer);

  while (uint8.length > 0) {
    // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
    // eslint-disable-next-line prefer-spread
    chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
    uint8 = uint8.subarray(chunkSize);
  }

  return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
}
/**
 * Get orientation value from given array buffer.
 * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
 * @returns {number} The read orientation value.
 */

function resetAndGetOrientation(arrayBuffer) {
  var dataView = new DataView(arrayBuffer);
  var orientation; // Ignores range error when the image does not have correct Exif information

  try {
    var littleEndian;
    var app1Start;
    var ifdStart; // Only handle JPEG image (start by 0xFFD8)

    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
      var length = dataView.byteLength;
      var offset = 2;

      while (offset + 1 < length) {
        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
          app1Start = offset;
          break;
        }

        offset += 1;
      }
    }

    if (app1Start) {
      var exifIDCode = app1Start + 4;
      var tiffOffset = app1Start + 10;

      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
        var endianness = dataView.getUint16(tiffOffset);
        littleEndian = endianness === 0x4949;

        if (littleEndian || endianness === 0x4D4D
        /* bigEndian */
        ) {
            if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
              var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

              if (firstIFDOffset >= 0x00000008) {
                ifdStart = tiffOffset + firstIFDOffset;
              }
            }
          }
      }
    }

    if (ifdStart) {
      var _length = dataView.getUint16(ifdStart, littleEndian);

      var _offset;

      var i;

      for (i = 0; i < _length; i += 1) {
        _offset = ifdStart + i * 12 + 2;

        if (dataView.getUint16(_offset, littleEndian) === 0x0112
        /* Orientation */
        ) {
            // 8 is the offset of the current tag's value
            _offset += 8; // Get the original orientation value

            orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

            dataView.setUint16(_offset, 1, littleEndian);
            break;
          }
      }
    }
  } catch (error) {
    orientation = 1;
  }

  return orientation;
}
/**
 * Parse Exif Orientation value.
 * @param {number} orientation - The orientation to parse.
 * @returns {Object} The parsed result.
 */

function parseOrientation(orientation) {
  var rotate = 0;
  var scaleX = 1;
  var scaleY = 1;

  switch (orientation) {
    // Flip horizontal
    case 2:
      scaleX = -1;
      break;
    // Rotate left 180°

    case 3:
      rotate = -180;
      break;
    // Flip vertical

    case 4:
      scaleY = -1;
      break;
    // Flip vertical and rotate right 90°

    case 5:
      rotate = 90;
      scaleY = -1;
      break;
    // Rotate right 90°

    case 6:
      rotate = 90;
      break;
    // Flip horizontal and rotate right 90°

    case 7:
      rotate = 90;
      scaleX = -1;
      break;
    // Rotate left 90°

    case 8:
      rotate = -90;
      break;
  }

  return {
    rotate: rotate,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var render = {
  render: function render() {
    this.initContainer();
    this.initCanvas();
    this.initCropBox();
    this.renderCanvas();

    if (this.cropped) {
      this.renderCropBox();
    }
  },
  initContainer: function initContainer() {
    var element = this.element,
        options = this.options,
        container = this.container,
        cropper = this.cropper;
    var minWidth = Number(options.minContainerWidth);
    var minHeight = Number(options.minContainerHeight);
    addClass(cropper, CLASS_HIDDEN);
    removeClass(element, CLASS_HIDDEN);
    var containerData = {
      width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
      height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
    };
    this.containerData = containerData;
    setStyle(cropper, {
      width: containerData.width,
      height: containerData.height
    });
    addClass(element, CLASS_HIDDEN);
    removeClass(cropper, CLASS_HIDDEN);
  },
  // Canvas (image wrapper)
  initCanvas: function initCanvas() {
    var containerData = this.containerData,
        imageData = this.imageData;
    var viewMode = this.options.viewMode;
    var rotated = Math.abs(imageData.rotate) % 180 === 90;
    var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
    var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
    var aspectRatio = naturalWidth / naturalHeight;
    var canvasWidth = containerData.width;
    var canvasHeight = containerData.height;

    if (containerData.height * aspectRatio > containerData.width) {
      if (viewMode === 3) {
        canvasWidth = containerData.height * aspectRatio;
      } else {
        canvasHeight = containerData.width / aspectRatio;
      }
    } else if (viewMode === 3) {
      canvasHeight = containerData.width / aspectRatio;
    } else {
      canvasWidth = containerData.height * aspectRatio;
    }

    var canvasData = {
      aspectRatio: aspectRatio,
      naturalWidth: naturalWidth,
      naturalHeight: naturalHeight,
      width: canvasWidth,
      height: canvasHeight
    };
    this.canvasData = canvasData;
    this.limited = viewMode === 1 || viewMode === 2;
    this.limitCanvas(true, true);
    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    canvasData.left = (containerData.width - canvasData.width) / 2;
    canvasData.top = (containerData.height - canvasData.height) / 2;
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    this.initialCanvasData = assign({}, canvasData);
  },
  limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var viewMode = options.viewMode;
    var aspectRatio = canvasData.aspectRatio;
    var cropped = this.cropped && cropBoxData;

    if (sizeLimited) {
      var minCanvasWidth = Number(options.minCanvasWidth) || 0;
      var minCanvasHeight = Number(options.minCanvasHeight) || 0;

      if (viewMode > 1) {
        minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
        minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

        if (viewMode === 3) {
          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      } else if (viewMode > 0) {
        if (minCanvasWidth) {
          minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
        } else if (minCanvasHeight) {
          minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
        } else if (cropped) {
          minCanvasWidth = cropBoxData.width;
          minCanvasHeight = cropBoxData.height;

          if (minCanvasHeight * aspectRatio > minCanvasWidth) {
            minCanvasWidth = minCanvasHeight * aspectRatio;
          } else {
            minCanvasHeight = minCanvasWidth / aspectRatio;
          }
        }
      }

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: minCanvasWidth,
        height: minCanvasHeight
      });

      minCanvasWidth = _getAdjustedSizes.width;
      minCanvasHeight = _getAdjustedSizes.height;
      canvasData.minWidth = minCanvasWidth;
      canvasData.minHeight = minCanvasHeight;
      canvasData.maxWidth = Infinity;
      canvasData.maxHeight = Infinity;
    }

    if (positionLimited) {
      if (viewMode > (cropped ? 0 : 1)) {
        var newCanvasLeft = containerData.width - canvasData.width;
        var newCanvasTop = containerData.height - canvasData.height;
        canvasData.minLeft = Math.min(0, newCanvasLeft);
        canvasData.minTop = Math.min(0, newCanvasTop);
        canvasData.maxLeft = Math.max(0, newCanvasLeft);
        canvasData.maxTop = Math.max(0, newCanvasTop);

        if (cropped && this.limited) {
          canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
          canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
          canvasData.maxLeft = cropBoxData.left;
          canvasData.maxTop = cropBoxData.top;

          if (viewMode === 2) {
            if (canvasData.width >= containerData.width) {
              canvasData.minLeft = Math.min(0, newCanvasLeft);
              canvasData.maxLeft = Math.max(0, newCanvasLeft);
            }

            if (canvasData.height >= containerData.height) {
              canvasData.minTop = Math.min(0, newCanvasTop);
              canvasData.maxTop = Math.max(0, newCanvasTop);
            }
          }
        }
      } else {
        canvasData.minLeft = -canvasData.width;
        canvasData.minTop = -canvasData.height;
        canvasData.maxLeft = containerData.width;
        canvasData.maxTop = containerData.height;
      }
    }
  },
  renderCanvas: function renderCanvas(changed, transformed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;

    if (transformed) {
      var _getRotatedSizes = getRotatedSizes({
        width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
        height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
        degree: imageData.rotate || 0
      }),
          naturalWidth = _getRotatedSizes.width,
          naturalHeight = _getRotatedSizes.height;

      var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
      var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
      canvasData.left -= (width - canvasData.width) / 2;
      canvasData.top -= (height - canvasData.height) / 2;
      canvasData.width = width;
      canvasData.height = height;
      canvasData.aspectRatio = naturalWidth / naturalHeight;
      canvasData.naturalWidth = naturalWidth;
      canvasData.naturalHeight = naturalHeight;
      this.limitCanvas(true, false);
    }

    if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
      canvasData.left = canvasData.oldLeft;
    }

    if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
      canvasData.top = canvasData.oldTop;
    }

    canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
    canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
    this.limitCanvas(false, true);
    canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
    canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
    canvasData.oldLeft = canvasData.left;
    canvasData.oldTop = canvasData.top;
    setStyle(this.canvas, assign({
      width: canvasData.width,
      height: canvasData.height
    }, getTransforms({
      translateX: canvasData.left,
      translateY: canvasData.top
    })));
    this.renderImage(changed);

    if (this.cropped && this.limited) {
      this.limitCropBox(true, true);
    }
  },
  renderImage: function renderImage(changed) {
    var canvasData = this.canvasData,
        imageData = this.imageData;
    var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
    var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
    assign(imageData, {
      width: width,
      height: height,
      left: (canvasData.width - width) / 2,
      top: (canvasData.height - height) / 2
    });
    setStyle(this.image, assign({
      width: imageData.width,
      height: imageData.height
    }, getTransforms(assign({
      translateX: imageData.left,
      translateY: imageData.top
    }, imageData))));

    if (changed) {
      this.output();
    }
  },
  initCropBox: function initCropBox() {
    var options = this.options,
        canvasData = this.canvasData;
    var aspectRatio = options.aspectRatio || options.initialAspectRatio;
    var autoCropArea = Number(options.autoCropArea) || 0.8;
    var cropBoxData = {
      width: canvasData.width,
      height: canvasData.height
    };

    if (aspectRatio) {
      if (canvasData.height * aspectRatio > canvasData.width) {
        cropBoxData.height = cropBoxData.width / aspectRatio;
      } else {
        cropBoxData.width = cropBoxData.height * aspectRatio;
      }
    }

    this.cropBoxData = cropBoxData;
    this.limitCropBox(true, true); // Initialize auto crop area

    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

    cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
    cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
    cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
    cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;
    this.initialCropBoxData = assign({}, cropBoxData);
  },
  limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
    var options = this.options,
        containerData = this.containerData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData,
        limited = this.limited;
    var aspectRatio = options.aspectRatio;

    if (sizeLimited) {
      var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
      var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
      var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
      var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

      minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
      minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

      if (aspectRatio) {
        if (minCropBoxWidth && minCropBoxHeight) {
          if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }
        } else if (minCropBoxWidth) {
          minCropBoxHeight = minCropBoxWidth / aspectRatio;
        } else if (minCropBoxHeight) {
          minCropBoxWidth = minCropBoxHeight * aspectRatio;
        }

        if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
          maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
        } else {
          maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
        }
      } // The minWidth/Height must be less than maxWidth/Height


      cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
      cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
      cropBoxData.maxWidth = maxCropBoxWidth;
      cropBoxData.maxHeight = maxCropBoxHeight;
    }

    if (positionLimited) {
      if (limited) {
        cropBoxData.minLeft = Math.max(0, canvasData.left);
        cropBoxData.minTop = Math.max(0, canvasData.top);
        cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
        cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
      } else {
        cropBoxData.minLeft = 0;
        cropBoxData.minTop = 0;
        cropBoxData.maxLeft = containerData.width - cropBoxData.width;
        cropBoxData.maxTop = containerData.height - cropBoxData.height;
      }
    }
  },
  renderCropBox: function renderCropBox() {
    var options = this.options,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData;

    if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
      cropBoxData.left = cropBoxData.oldLeft;
    }

    if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
      cropBoxData.top = cropBoxData.oldTop;
    }

    cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
    cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
    this.limitCropBox(false, true);
    cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
    cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
    cropBoxData.oldLeft = cropBoxData.left;
    cropBoxData.oldTop = cropBoxData.top;

    if (options.movable && options.cropBoxMovable) {
      // Turn to move the canvas when the crop box is equal to the container
      setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
    }

    setStyle(this.cropBox, assign({
      width: cropBoxData.width,
      height: cropBoxData.height
    }, getTransforms({
      translateX: cropBoxData.left,
      translateY: cropBoxData.top
    })));

    if (this.cropped && this.limited) {
      this.limitCanvas(true, true);
    }

    if (!this.disabled) {
      this.output();
    }
  },
  output: function output() {
    this.preview();
    dispatchEvent(this.element, EVENT_CROP, this.getData());
  }
};

var preview = {
  initPreview: function initPreview() {
    var element = this.element,
        crossOrigin = this.crossOrigin;
    var preview = this.options.preview;
    var url = crossOrigin ? this.crossOriginUrl : this.url;
    var alt = element.alt || 'The image to preview';
    var image = document.createElement('img');

    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }

    image.src = url;
    image.alt = alt;
    this.viewBox.appendChild(image);
    this.viewBoxImage = image;

    if (!preview) {
      return;
    }

    var previews = preview;

    if (typeof preview === 'string') {
      previews = element.ownerDocument.querySelectorAll(preview);
    } else if (preview.querySelector) {
      previews = [preview];
    }

    this.previews = previews;
    forEach(previews, function (el) {
      var img = document.createElement('img'); // Save the original size for recover

      setData(el, DATA_PREVIEW, {
        width: el.offsetWidth,
        height: el.offsetHeight,
        html: el.innerHTML
      });

      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.src = url;
      img.alt = alt;
      /**
       * Override img element styles
       * Add `display:block` to avoid margin top issue
       * Add `height:auto` to override `height` attribute on IE8
       * (Occur only when margin-top <= -height)
       */

      img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
      el.innerHTML = '';
      el.appendChild(img);
    });
  },
  resetPreview: function resetPreview() {
    forEach(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);
      setStyle(element, {
        width: data.width,
        height: data.height
      });
      element.innerHTML = data.html;
      removeData(element, DATA_PREVIEW);
    });
  },
  preview: function preview() {
    var imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var cropBoxWidth = cropBoxData.width,
        cropBoxHeight = cropBoxData.height;
    var width = imageData.width,
        height = imageData.height;
    var left = cropBoxData.left - canvasData.left - imageData.left;
    var top = cropBoxData.top - canvasData.top - imageData.top;

    if (!this.cropped || this.disabled) {
      return;
    }

    setStyle(this.viewBoxImage, assign({
      width: width,
      height: height
    }, getTransforms(assign({
      translateX: -left,
      translateY: -top
    }, imageData))));
    forEach(this.previews, function (element) {
      var data = getData(element, DATA_PREVIEW);
      var originalWidth = data.width;
      var originalHeight = data.height;
      var newWidth = originalWidth;
      var newHeight = originalHeight;
      var ratio = 1;

      if (cropBoxWidth) {
        ratio = originalWidth / cropBoxWidth;
        newHeight = cropBoxHeight * ratio;
      }

      if (cropBoxHeight && newHeight > originalHeight) {
        ratio = originalHeight / cropBoxHeight;
        newWidth = cropBoxWidth * ratio;
        newHeight = originalHeight;
      }

      setStyle(element, {
        width: newWidth,
        height: newHeight
      });
      setStyle(element.getElementsByTagName('img')[0], assign({
        width: width * ratio,
        height: height * ratio
      }, getTransforms(assign({
        translateX: -left * ratio,
        translateY: -top * ratio
      }, imageData))));
    });
  }
};

var events = {
  bind: function bind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;

    if (isFunction(options.cropstart)) {
      addListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction(options.cropmove)) {
      addListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction(options.cropend)) {
      addListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction(options.crop)) {
      addListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction(options.zoom)) {
      addListener(element, EVENT_ZOOM, options.zoom);
    }

    addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

    if (options.zoomable && options.zoomOnWheel) {
      addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
        passive: false,
        capture: true
      });
    }

    if (options.toggleDragModeOnDblclick) {
      addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
    }

    addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
    addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

    if (options.responsive) {
      addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
    }
  },
  unbind: function unbind() {
    var element = this.element,
        options = this.options,
        cropper = this.cropper;

    if (isFunction(options.cropstart)) {
      removeListener(element, EVENT_CROP_START, options.cropstart);
    }

    if (isFunction(options.cropmove)) {
      removeListener(element, EVENT_CROP_MOVE, options.cropmove);
    }

    if (isFunction(options.cropend)) {
      removeListener(element, EVENT_CROP_END, options.cropend);
    }

    if (isFunction(options.crop)) {
      removeListener(element, EVENT_CROP, options.crop);
    }

    if (isFunction(options.zoom)) {
      removeListener(element, EVENT_ZOOM, options.zoom);
    }

    removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

    if (options.zoomable && options.zoomOnWheel) {
      removeListener(cropper, EVENT_WHEEL, this.onWheel, {
        passive: false,
        capture: true
      });
    }

    if (options.toggleDragModeOnDblclick) {
      removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
    }

    removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
    removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

    if (options.responsive) {
      removeListener(window, EVENT_RESIZE, this.onResize);
    }
  }
};

var handlers = {
  resize: function resize() {
    if (this.disabled) {
      return;
    }

    var options = this.options,
        container = this.container,
        containerData = this.containerData;
    var ratioX = container.offsetWidth / containerData.width;
    var ratioY = container.offsetHeight / containerData.height;
    var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY; // Resize when width changed or height changed

    if (ratio !== 1) {
      var canvasData;
      var cropBoxData;

      if (options.restore) {
        canvasData = this.getCanvasData();
        cropBoxData = this.getCropBoxData();
      }

      this.render();

      if (options.restore) {
        this.setCanvasData(forEach(canvasData, function (n, i) {
          canvasData[i] = n * ratio;
        }));
        this.setCropBoxData(forEach(cropBoxData, function (n, i) {
          cropBoxData[i] = n * ratio;
        }));
      }
    }
  },
  dblclick: function dblclick() {
    if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
      return;
    }

    this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
  },
  wheel: function wheel(event) {
    var _this = this;

    var ratio = Number(this.options.wheelZoomRatio) || 0.1;
    var delta = 1;

    if (this.disabled) {
      return;
    }

    event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

    if (this.wheeling) {
      return;
    }

    this.wheeling = true;
    setTimeout(function () {
      _this.wheeling = false;
    }, 50);

    if (event.deltaY) {
      delta = event.deltaY > 0 ? 1 : -1;
    } else if (event.wheelDelta) {
      delta = -event.wheelDelta / 120;
    } else if (event.detail) {
      delta = event.detail > 0 ? 1 : -1;
    }

    this.zoom(-delta * ratio, event);
  },
  cropStart: function cropStart(event) {
    var buttons = event.buttons,
        button = event.button;

    if (this.disabled // Handle mouse event and pointer event and ignore touch event
    || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
    isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
    || event.ctrlKey)) {
      return;
    }

    var options = this.options,
        pointers = this.pointers;
    var action;

    if (event.changedTouches) {
      // Handle touch event
      forEach(event.changedTouches, function (touch) {
        pointers[touch.identifier] = getPointer(touch);
      });
    } else {
      // Handle mouse event and pointer event
      pointers[event.pointerId || 0] = getPointer(event);
    }

    if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
      action = ACTION_ZOOM;
    } else {
      action = getData(event.target, DATA_ACTION);
    }

    if (!REGEXP_ACTIONS.test(action)) {
      return;
    }

    if (dispatchEvent(this.element, EVENT_CROP_START, {
      originalEvent: event,
      action: action
    }) === false) {
      return;
    } // This line is required for preventing page zooming in iOS browsers


    event.preventDefault();
    this.action = action;
    this.cropping = false;

    if (action === ACTION_CROP) {
      this.cropping = true;
      addClass(this.dragBox, CLASS_MODAL);
    }
  },
  cropMove: function cropMove(event) {
    var action = this.action;

    if (this.disabled || !action) {
      return;
    }

    var pointers = this.pointers;
    event.preventDefault();

    if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
      originalEvent: event,
      action: action
    }) === false) {
      return;
    }

    if (event.changedTouches) {
      forEach(event.changedTouches, function (touch) {
        // The first parameter should not be undefined (#432)
        assign(pointers[touch.identifier] || {}, getPointer(touch, true));
      });
    } else {
      assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
    }

    this.change(event);
  },
  cropEnd: function cropEnd(event) {
    if (this.disabled) {
      return;
    }

    var action = this.action,
        pointers = this.pointers;

    if (event.changedTouches) {
      forEach(event.changedTouches, function (touch) {
        delete pointers[touch.identifier];
      });
    } else {
      delete pointers[event.pointerId || 0];
    }

    if (!action) {
      return;
    }

    event.preventDefault();

    if (!Object.keys(pointers).length) {
      this.action = '';
    }

    if (this.cropping) {
      this.cropping = false;
      toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
    }

    dispatchEvent(this.element, EVENT_CROP_END, {
      originalEvent: event,
      action: action
    });
  }
};

var change = {
  change: function change(event) {
    var options = this.options,
        canvasData = this.canvasData,
        containerData = this.containerData,
        cropBoxData = this.cropBoxData,
        pointers = this.pointers;
    var action = this.action;
    var aspectRatio = options.aspectRatio;
    var left = cropBoxData.left,
        top = cropBoxData.top,
        width = cropBoxData.width,
        height = cropBoxData.height;
    var right = left + width;
    var bottom = top + height;
    var minLeft = 0;
    var minTop = 0;
    var maxWidth = containerData.width;
    var maxHeight = containerData.height;
    var renderable = true;
    var offset; // Locking aspect ratio in "free mode" by holding shift key

    if (!aspectRatio && event.shiftKey) {
      aspectRatio = width && height ? width / height : 1;
    }

    if (this.limited) {
      minLeft = cropBoxData.minLeft;
      minTop = cropBoxData.minTop;
      maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
      maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
    }

    var pointer = pointers[Object.keys(pointers)[0]];
    var range = {
      x: pointer.endX - pointer.startX,
      y: pointer.endY - pointer.startY
    };

    var check = function check(side) {
      switch (side) {
        case ACTION_EAST:
          if (right + range.x > maxWidth) {
            range.x = maxWidth - right;
          }

          break;

        case ACTION_WEST:
          if (left + range.x < minLeft) {
            range.x = minLeft - left;
          }

          break;

        case ACTION_NORTH:
          if (top + range.y < minTop) {
            range.y = minTop - top;
          }

          break;

        case ACTION_SOUTH:
          if (bottom + range.y > maxHeight) {
            range.y = maxHeight - bottom;
          }

          break;
      }
    };

    switch (action) {
      // Move crop box
      case ACTION_ALL:
        left += range.x;
        top += range.y;
        break;
      // Resize crop box

      case ACTION_EAST:
        if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_EAST);
        width += range.x;

        if (width < 0) {
          action = ACTION_WEST;
          width = -width;
          left -= width;
        }

        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }

        break;

      case ACTION_NORTH:
        if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_NORTH);
        height -= range.y;
        top += range.y;

        if (height < 0) {
          action = ACTION_SOUTH;
          height = -height;
          top -= height;
        }

        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }

        break;

      case ACTION_WEST:
        if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
          renderable = false;
          break;
        }

        check(ACTION_WEST);
        width -= range.x;
        left += range.x;

        if (width < 0) {
          action = ACTION_EAST;
          width = -width;
          left -= width;
        }

        if (aspectRatio) {
          height = width / aspectRatio;
          top += (cropBoxData.height - height) / 2;
        }

        break;

      case ACTION_SOUTH:
        if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
          renderable = false;
          break;
        }

        check(ACTION_SOUTH);
        height += range.y;

        if (height < 0) {
          action = ACTION_NORTH;
          height = -height;
          top -= height;
        }

        if (aspectRatio) {
          width = height * aspectRatio;
          left += (cropBoxData.width - width) / 2;
        }

        break;

      case ACTION_NORTH_EAST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
        } else {
          check(ACTION_NORTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_NORTH_WEST:
        if (aspectRatio) {
          if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;
          width = height * aspectRatio;
          left += cropBoxData.width - width;
        } else {
          check(ACTION_NORTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y <= 0 && top <= minTop) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y <= 0) {
            if (top > minTop) {
              height -= range.y;
              top += range.y;
            }
          } else {
            height -= range.y;
            top += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_SOUTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_NORTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_SOUTH_WEST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_SOUTH_WEST:
        if (aspectRatio) {
          if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_WEST);

          if (range.x <= 0) {
            if (left > minLeft) {
              width -= range.x;
              left += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width -= range.x;
            left += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_EAST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          top -= height;
        }

        break;

      case ACTION_SOUTH_EAST:
        if (aspectRatio) {
          if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;
          height = width / aspectRatio;
        } else {
          check(ACTION_SOUTH);
          check(ACTION_EAST);

          if (range.x >= 0) {
            if (right < maxWidth) {
              width += range.x;
            } else if (range.y >= 0 && bottom >= maxHeight) {
              renderable = false;
            }
          } else {
            width += range.x;
          }

          if (range.y >= 0) {
            if (bottom < maxHeight) {
              height += range.y;
            }
          } else {
            height += range.y;
          }
        }

        if (width < 0 && height < 0) {
          action = ACTION_NORTH_WEST;
          height = -height;
          width = -width;
          top -= height;
          left -= width;
        } else if (width < 0) {
          action = ACTION_SOUTH_WEST;
          width = -width;
          left -= width;
        } else if (height < 0) {
          action = ACTION_NORTH_EAST;
          height = -height;
          top -= height;
        }

        break;
      // Move canvas

      case ACTION_MOVE:
        this.move(range.x, range.y);
        renderable = false;
        break;
      // Zoom canvas

      case ACTION_ZOOM:
        this.zoom(getMaxZoomRatio(pointers), event);
        renderable = false;
        break;
      // Create crop box

      case ACTION_CROP:
        if (!range.x || !range.y) {
          renderable = false;
          break;
        }

        offset = getOffset(this.cropper);
        left = pointer.startX - offset.left;
        top = pointer.startY - offset.top;
        width = cropBoxData.minWidth;
        height = cropBoxData.minHeight;

        if (range.x > 0) {
          action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
        } else if (range.x < 0) {
          left -= width;
          action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
        }

        if (range.y < 0) {
          top -= height;
        } // Show the crop box if is hidden


        if (!this.cropped) {
          removeClass(this.cropBox, CLASS_HIDDEN);
          this.cropped = true;

          if (this.limited) {
            this.limitCropBox(true, true);
          }
        }

        break;
    }

    if (renderable) {
      cropBoxData.width = width;
      cropBoxData.height = height;
      cropBoxData.left = left;
      cropBoxData.top = top;
      this.action = action;
      this.renderCropBox();
    } // Override


    forEach(pointers, function (p) {
      p.startX = p.endX;
      p.startY = p.endY;
    });
  }
};

var methods = {
  // Show the crop box manually
  crop: function crop() {
    if (this.ready && !this.cropped && !this.disabled) {
      this.cropped = true;
      this.limitCropBox(true, true);

      if (this.options.modal) {
        addClass(this.dragBox, CLASS_MODAL);
      }

      removeClass(this.cropBox, CLASS_HIDDEN);
      this.setCropBoxData(this.initialCropBoxData);
    }

    return this;
  },
  // Reset the image and crop box to their initial states
  reset: function reset() {
    if (this.ready && !this.disabled) {
      this.imageData = assign({}, this.initialImageData);
      this.canvasData = assign({}, this.initialCanvasData);
      this.cropBoxData = assign({}, this.initialCropBoxData);
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    }

    return this;
  },
  // Clear the crop box
  clear: function clear() {
    if (this.cropped && !this.disabled) {
      assign(this.cropBoxData, {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      });
      this.cropped = false;
      this.renderCropBox();
      this.limitCanvas(true, true); // Render canvas after crop box rendered

      this.renderCanvas();
      removeClass(this.dragBox, CLASS_MODAL);
      addClass(this.cropBox, CLASS_HIDDEN);
    }

    return this;
  },

  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
   * @returns {Cropper} this
   */
  replace: function replace(url) {
    var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!this.disabled && url) {
      if (this.isImg) {
        this.element.src = url;
      }

      if (hasSameSize) {
        this.url = url;
        this.image.src = url;

        if (this.ready) {
          this.viewBoxImage.src = url;
          forEach(this.previews, function (element) {
            element.getElementsByTagName('img')[0].src = url;
          });
        }
      } else {
        if (this.isImg) {
          this.replaced = true;
        }

        this.options.data = null;
        this.uncreate();
        this.load(url);
      }
    }

    return this;
  },
  // Enable (unfreeze) the cropper
  enable: function enable() {
    if (this.ready && this.disabled) {
      this.disabled = false;
      removeClass(this.cropper, CLASS_DISABLED);
    }

    return this;
  },
  // Disable (freeze) the cropper
  disable: function disable() {
    if (this.ready && !this.disabled) {
      this.disabled = true;
      addClass(this.cropper, CLASS_DISABLED);
    }

    return this;
  },

  /**
   * Destroy the cropper and remove the instance from the image
   * @returns {Cropper} this
   */
  destroy: function destroy() {
    var element = this.element;

    if (!element[NAMESPACE]) {
      return this;
    }

    element[NAMESPACE] = undefined;

    if (this.isImg && this.replaced) {
      element.src = this.originalUrl;
    }

    this.uncreate();
    return this;
  },

  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
   * @returns {Cropper} this
   */
  move: function move(offsetX) {
    var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
    var _this$canvasData = this.canvasData,
        left = _this$canvasData.left,
        top = _this$canvasData.top;
    return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
  },

  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Cropper} this
   */
  moveTo: function moveTo(x) {
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    var canvasData = this.canvasData;
    var changed = false;
    x = Number(x);
    y = Number(y);

    if (this.ready && !this.disabled && this.options.movable) {
      if (isNumber(x)) {
        canvasData.left = x;
        changed = true;
      }

      if (isNumber(y)) {
        canvasData.top = y;
        changed = true;
      }

      if (changed) {
        this.renderCanvas(true);
      }
    }

    return this;
  },

  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoom: function zoom(ratio, _originalEvent) {
    var canvasData = this.canvasData;
    ratio = Number(ratio);

    if (ratio < 0) {
      ratio = 1 / (1 - ratio);
    } else {
      ratio = 1 + ratio;
    }

    return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
  },

  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Object} pivot - The zoom pivot point coordinate.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
    var options = this.options,
        canvasData = this.canvasData;
    var width = canvasData.width,
        height = canvasData.height,
        naturalWidth = canvasData.naturalWidth,
        naturalHeight = canvasData.naturalHeight;
    ratio = Number(ratio);

    if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
      var newWidth = naturalWidth * ratio;
      var newHeight = naturalHeight * ratio;

      if (dispatchEvent(this.element, EVENT_ZOOM, {
        ratio: ratio,
        oldRatio: width / naturalWidth,
        originalEvent: _originalEvent
      }) === false) {
        return this;
      }

      if (_originalEvent) {
        var pointers = this.pointers;
        var offset = getOffset(this.cropper);
        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
          pageX: _originalEvent.pageX,
          pageY: _originalEvent.pageY
        }; // Zoom from the triggering point of the event

        canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
      } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
        canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
        canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
      } else {
        // Zoom from the center of the canvas
        canvasData.left -= (newWidth - width) / 2;
        canvasData.top -= (newHeight - height) / 2;
      }

      canvasData.width = newWidth;
      canvasData.height = newHeight;
      this.renderCanvas(true);
    }

    return this;
  },

  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotate: function rotate(degree) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
  },

  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotateTo: function rotateTo(degree) {
    degree = Number(degree);

    if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
      this.imageData.rotate = degree % 360;
      this.renderCanvas(true, true);
    }

    return this;
  },

  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Cropper} this
   */
  scaleX: function scaleX(_scaleX) {
    var scaleY = this.imageData.scaleY;
    return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
  },

  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scaleY: function scaleY(_scaleY) {
    var scaleX = this.imageData.scaleX;
    return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
  },

  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scale: function scale(scaleX) {
    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
    var imageData = this.imageData;
    var transformed = false;
    scaleX = Number(scaleX);
    scaleY = Number(scaleY);

    if (this.ready && !this.disabled && this.options.scalable) {
      if (isNumber(scaleX)) {
        imageData.scaleX = scaleX;
        transformed = true;
      }

      if (isNumber(scaleY)) {
        imageData.scaleY = scaleY;
        transformed = true;
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }
    }

    return this;
  },

  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function getData() {
    var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData,
        cropBoxData = this.cropBoxData;
    var data;

    if (this.ready && this.cropped) {
      data = {
        x: cropBoxData.left - canvasData.left,
        y: cropBoxData.top - canvasData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
      var ratio = imageData.width / imageData.naturalWidth;
      forEach(data, function (n, i) {
        data[i] = n / ratio;
      });

      if (rounded) {
        // In case rounding off leads to extra 1px in right or bottom border
        // we should round the top-left corner and the dimension (#343).
        var bottom = Math.round(data.y + data.height);
        var right = Math.round(data.x + data.width);
        data.x = Math.round(data.x);
        data.y = Math.round(data.y);
        data.width = right - data.x;
        data.height = bottom - data.y;
      }
    } else {
      data = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }

    if (options.rotatable) {
      data.rotate = imageData.rotate || 0;
    }

    if (options.scalable) {
      data.scaleX = imageData.scaleX || 1;
      data.scaleY = imageData.scaleY || 1;
    }

    return data;
  },

  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Cropper} this
   */
  setData: function setData(data) {
    var options = this.options,
        imageData = this.imageData,
        canvasData = this.canvasData;
    var cropBoxData = {};

    if (this.ready && !this.disabled && isPlainObject(data)) {
      var transformed = false;

      if (options.rotatable) {
        if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
          imageData.rotate = data.rotate;
          transformed = true;
        }
      }

      if (options.scalable) {
        if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
          imageData.scaleX = data.scaleX;
          transformed = true;
        }

        if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
          imageData.scaleY = data.scaleY;
          transformed = true;
        }
      }

      if (transformed) {
        this.renderCanvas(true, true);
      }

      var ratio = imageData.width / imageData.naturalWidth;

      if (isNumber(data.x)) {
        cropBoxData.left = data.x * ratio + canvasData.left;
      }

      if (isNumber(data.y)) {
        cropBoxData.top = data.y * ratio + canvasData.top;
      }

      if (isNumber(data.width)) {
        cropBoxData.width = data.width * ratio;
      }

      if (isNumber(data.height)) {
        cropBoxData.height = data.height * ratio;
      }

      this.setCropBoxData(cropBoxData);
    }

    return this;
  },

  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function getContainerData() {
    return this.ready ? assign({}, this.containerData) : {};
  },

  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function getImageData() {
    return this.sized ? assign({}, this.imageData) : {};
  },

  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function getCanvasData() {
    var canvasData = this.canvasData;
    var data = {};

    if (this.ready) {
      forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
        data[n] = canvasData[n];
      });
    }

    return data;
  },

  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Cropper} this
   */
  setCanvasData: function setCanvasData(data) {
    var canvasData = this.canvasData;
    var aspectRatio = canvasData.aspectRatio;

    if (this.ready && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        canvasData.left = data.left;
      }

      if (isNumber(data.top)) {
        canvasData.top = data.top;
      }

      if (isNumber(data.width)) {
        canvasData.width = data.width;
        canvasData.height = data.width / aspectRatio;
      } else if (isNumber(data.height)) {
        canvasData.height = data.height;
        canvasData.width = data.height * aspectRatio;
      }

      this.renderCanvas(true);
    }

    return this;
  },

  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function getCropBoxData() {
    var cropBoxData = this.cropBoxData;
    var data;

    if (this.ready && this.cropped) {
      data = {
        left: cropBoxData.left,
        top: cropBoxData.top,
        width: cropBoxData.width,
        height: cropBoxData.height
      };
    }

    return data || {};
  },

  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Cropper} this
   */
  setCropBoxData: function setCropBoxData(data) {
    var cropBoxData = this.cropBoxData;
    var aspectRatio = this.options.aspectRatio;
    var widthChanged;
    var heightChanged;

    if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
      if (isNumber(data.left)) {
        cropBoxData.left = data.left;
      }

      if (isNumber(data.top)) {
        cropBoxData.top = data.top;
      }

      if (isNumber(data.width) && data.width !== cropBoxData.width) {
        widthChanged = true;
        cropBoxData.width = data.width;
      }

      if (isNumber(data.height) && data.height !== cropBoxData.height) {
        heightChanged = true;
        cropBoxData.height = data.height;
      }

      if (aspectRatio) {
        if (widthChanged) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else if (heightChanged) {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.renderCropBox();
    }

    return this;
  },

  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function getCroppedCanvas() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this.ready || !window.HTMLCanvasElement) {
      return null;
    }

    var canvasData = this.canvasData;
    var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

    if (!this.cropped) {
      return source;
    }

    var _this$getData = this.getData(),
        initialX = _this$getData.x,
        initialY = _this$getData.y,
        initialWidth = _this$getData.width,
        initialHeight = _this$getData.height;

    var ratio = source.width / Math.floor(canvasData.naturalWidth);

    if (ratio !== 1) {
      initialX *= ratio;
      initialY *= ratio;
      initialWidth *= ratio;
      initialHeight *= ratio;
    }

    var aspectRatio = initialWidth / initialHeight;
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.maxWidth || Infinity,
      height: options.maxHeight || Infinity
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.minWidth || 0,
      height: options.minHeight || 0
    }, 'cover');

    var _getAdjustedSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: options.width || (ratio !== 1 ? source.width : initialWidth),
      height: options.height || (ratio !== 1 ? source.height : initialHeight)
    }),
        width = _getAdjustedSizes.width,
        height = _getAdjustedSizes.height;

    width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
    height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = options.fillColor || 'transparent';
    context.fillRect(0, 0, width, height);
    var _options$imageSmoothi = options.imageSmoothingEnabled,
        imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
        imageSmoothingQuality = options.imageSmoothingQuality;
    context.imageSmoothingEnabled = imageSmoothingEnabled;

    if (imageSmoothingQuality) {
      context.imageSmoothingQuality = imageSmoothingQuality;
    } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


    var sourceWidth = source.width;
    var sourceHeight = source.height; // Source canvas parameters

    var srcX = initialX;
    var srcY = initialY;
    var srcWidth;
    var srcHeight; // Destination canvas parameters

    var dstX;
    var dstY;
    var dstWidth;
    var dstHeight;

    if (srcX <= -initialWidth || srcX > sourceWidth) {
      srcX = 0;
      srcWidth = 0;
      dstX = 0;
      dstWidth = 0;
    } else if (srcX <= 0) {
      dstX = -srcX;
      srcX = 0;
      srcWidth = Math.min(sourceWidth, initialWidth + srcX);
      dstWidth = srcWidth;
    } else if (srcX <= sourceWidth) {
      dstX = 0;
      srcWidth = Math.min(initialWidth, sourceWidth - srcX);
      dstWidth = srcWidth;
    }

    if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
      srcY = 0;
      srcHeight = 0;
      dstY = 0;
      dstHeight = 0;
    } else if (srcY <= 0) {
      dstY = -srcY;
      srcY = 0;
      srcHeight = Math.min(sourceHeight, initialHeight + srcY);
      dstHeight = srcHeight;
    } else if (srcY <= sourceHeight) {
      dstY = 0;
      srcHeight = Math.min(initialHeight, sourceHeight - srcY);
      dstHeight = srcHeight;
    }

    var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

    if (dstWidth > 0 && dstHeight > 0) {
      var scale = width / initialWidth;
      params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
    } // All the numerical parameters should be integer for `drawImage`
    // https://github.com/fengyuanchen/cropper/issues/476


    context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    return canvas;
  },

  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Cropper} this
   */
  setAspectRatio: function setAspectRatio(aspectRatio) {
    var options = this.options;

    if (!this.disabled && !isUndefined(aspectRatio)) {
      // 0 -> NaN
      options.aspectRatio = Math.max(0, aspectRatio) || NaN;

      if (this.ready) {
        this.initCropBox();

        if (this.cropped) {
          this.renderCropBox();
        }
      }
    }

    return this;
  },

  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Cropper} this
   */
  setDragMode: function setDragMode(mode) {
    var options = this.options,
        dragBox = this.dragBox,
        face = this.face;

    if (this.ready && !this.disabled) {
      var croppable = mode === DRAG_MODE_CROP;
      var movable = options.movable && mode === DRAG_MODE_MOVE;
      mode = croppable || movable ? mode : DRAG_MODE_NONE;
      options.dragMode = mode;
      setData(dragBox, DATA_ACTION, mode);
      toggleClass(dragBox, CLASS_CROP, croppable);
      toggleClass(dragBox, CLASS_MOVE, movable);

      if (!options.cropBoxMovable) {
        // Sync drag mode to crop box when it is not movable
        setData(face, DATA_ACTION, mode);
        toggleClass(face, CLASS_CROP, croppable);
        toggleClass(face, CLASS_MOVE, movable);
      }
    }

    return this;
  }
};

var AnotherCropper = WINDOW.Cropper;

var Cropper = /*#__PURE__*/function () {
  /**
   * Create a new Cropper.
   * @param {Element} element - The target element for cropping.
   * @param {Object} [options={}] - The configuration options.
   */
  function Cropper(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Cropper);

    if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
      throw new Error('The first argument is required and must be an <img> or <canvas> element.');
    }

    this.element = element;
    this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
    this.cropped = false;
    this.disabled = false;
    this.pointers = {};
    this.ready = false;
    this.reloading = false;
    this.replaced = false;
    this.sized = false;
    this.sizing = false;
    this.init();
  }

  _createClass(Cropper, [{
    key: "init",
    value: function init() {
      var element = this.element;
      var tagName = element.tagName.toLowerCase();
      var url;

      if (element[NAMESPACE]) {
        return;
      }

      element[NAMESPACE] = this;

      if (tagName === 'img') {
        this.isImg = true; // e.g.: "img/picture.jpg"

        url = element.getAttribute('src') || '';
        this.originalUrl = url; // Stop when it's a blank image

        if (!url) {
          return;
        } // e.g.: "https://example.com/img/picture.jpg"


        url = element.src;
      } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
        url = element.toDataURL();
      }

      this.load(url);
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this = this;

      if (!url) {
        return;
      }

      this.url = url;
      this.imageData = {};
      var element = this.element,
          options = this.options;

      if (!options.rotatable && !options.scalable) {
        options.checkOrientation = false;
      } // Only IE10+ supports Typed Arrays


      if (!options.checkOrientation || !window.ArrayBuffer) {
        this.clone();
        return;
      } // Detect the mime type of the image directly if it is a Data URL


      if (REGEXP_DATA_URL.test(url)) {
        // Read ArrayBuffer from Data URL of JPEG images directly for better performance
        if (REGEXP_DATA_URL_JPEG.test(url)) {
          this.read(dataURLToArrayBuffer(url));
        } else {
          // Only a JPEG image may contains Exif Orientation information,
          // the rest types of Data URLs are not necessary to check orientation at all.
          this.clone();
        }

        return;
      } // 1. Detect the mime type of the image by a XMLHttpRequest.
      // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


      var xhr = new XMLHttpRequest();
      var clone = this.clone.bind(this);
      this.reloading = true;
      this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
      // http, https, data, chrome, chrome-extension.
      // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
      // in some browsers as IE11 and Safari.

      xhr.onabort = clone;
      xhr.onerror = clone;
      xhr.ontimeout = clone;

      xhr.onprogress = function () {
        // Abort the request directly if it not a JPEG image for better performance
        if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
          xhr.abort();
        }
      };

      xhr.onload = function () {
        _this.read(xhr.response);
      };

      xhr.onloadend = function () {
        _this.reloading = false;
        _this.xhr = null;
      }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


      if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
        url = addTimestamp(url);
      } // The third parameter is required for avoiding side-effect (#682)


      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';
      xhr.withCredentials = element.crossOrigin === 'use-credentials';
      xhr.send();
    }
  }, {
    key: "read",
    value: function read(arrayBuffer) {
      var options = this.options,
          imageData = this.imageData; // Reset the orientation value to its default value 1
      // as some iOS browsers will render image with its orientation

      var orientation = resetAndGetOrientation(arrayBuffer);
      var rotate = 0;
      var scaleX = 1;
      var scaleY = 1;

      if (orientation > 1) {
        // Generate a new URL which has the default orientation value
        this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

        var _parseOrientation = parseOrientation(orientation);

        rotate = _parseOrientation.rotate;
        scaleX = _parseOrientation.scaleX;
        scaleY = _parseOrientation.scaleY;
      }

      if (options.rotatable) {
        imageData.rotate = rotate;
      }

      if (options.scalable) {
        imageData.scaleX = scaleX;
        imageData.scaleY = scaleY;
      }

      this.clone();
    }
  }, {
    key: "clone",
    value: function clone() {
      var element = this.element,
          url = this.url;
      var crossOrigin = element.crossOrigin;
      var crossOriginUrl = url;

      if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
        if (!crossOrigin) {
          crossOrigin = 'anonymous';
        } // Bust cache when there is not a "crossOrigin" property (#519)


        crossOriginUrl = addTimestamp(url);
      }

      this.crossOrigin = crossOrigin;
      this.crossOriginUrl = crossOriginUrl;
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = crossOriginUrl || url;
      image.alt = element.alt || 'The image to crop';
      this.image = image;
      image.onload = this.start.bind(this);
      image.onerror = this.stop.bind(this);
      addClass(image, CLASS_HIDE);
      element.parentNode.insertBefore(image, element.nextSibling);
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var image = this.image;
      image.onload = null;
      image.onerror = null;
      this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
      // such as Safari for iOS, Chrome for iOS, and in-app browsers.

      var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

      var done = function done(naturalWidth, naturalHeight) {
        assign(_this2.imageData, {
          naturalWidth: naturalWidth,
          naturalHeight: naturalHeight,
          aspectRatio: naturalWidth / naturalHeight
        });
        _this2.initialImageData = assign({}, _this2.imageData);
        _this2.sizing = false;
        _this2.sized = true;

        _this2.build();
      }; // Most modern browsers (excepts iOS WebKit)


      if (image.naturalWidth && !isIOSWebKit) {
        done(image.naturalWidth, image.naturalHeight);
        return;
      }

      var sizingImage = document.createElement('img');
      var body = document.body || document.documentElement;
      this.sizingImage = sizingImage;

      sizingImage.onload = function () {
        done(sizingImage.width, sizingImage.height);

        if (!isIOSWebKit) {
          body.removeChild(sizingImage);
        }
      };

      sizingImage.src = image.src; // iOS WebKit will convert the image automatically
      // with its orientation once append it into DOM (#279)

      if (!isIOSWebKit) {
        sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
        body.appendChild(sizingImage);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var image = this.image;
      image.onload = null;
      image.onerror = null;
      image.parentNode.removeChild(image);
      this.image = null;
    }
  }, {
    key: "build",
    value: function build() {
      if (!this.sized || this.ready) {
        return;
      }

      var element = this.element,
          options = this.options,
          image = this.image; // Create cropper elements

      var container = element.parentNode;
      var template = document.createElement('div');
      template.innerHTML = TEMPLATE;
      var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
      var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
      var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
      var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
      var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
      this.container = container;
      this.cropper = cropper;
      this.canvas = canvas;
      this.dragBox = dragBox;
      this.cropBox = cropBox;
      this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
      this.face = face;
      canvas.appendChild(image); // Hide the original image

      addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

      container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

      if (!this.isImg) {
        removeClass(image, CLASS_HIDE);
      }

      this.initPreview();
      this.bind();
      options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
      options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
      options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
      addClass(cropBox, CLASS_HIDDEN);

      if (!options.guides) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
      }

      if (!options.center) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
      }

      if (options.background) {
        addClass(cropper, "".concat(NAMESPACE, "-bg"));
      }

      if (!options.highlight) {
        addClass(face, CLASS_INVISIBLE);
      }

      if (options.cropBoxMovable) {
        addClass(face, CLASS_MOVE);
        setData(face, DATA_ACTION, ACTION_ALL);
      }

      if (!options.cropBoxResizable) {
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
        addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
      }

      this.render();
      this.ready = true;
      this.setDragMode(options.dragMode);

      if (options.autoCrop) {
        this.crop();
      }

      this.setData(options.data);

      if (isFunction(options.ready)) {
        addListener(element, EVENT_READY, options.ready, {
          once: true
        });
      }

      dispatchEvent(element, EVENT_READY);
    }
  }, {
    key: "unbuild",
    value: function unbuild() {
      if (!this.ready) {
        return;
      }

      this.ready = false;
      this.unbind();
      this.resetPreview();
      this.cropper.parentNode.removeChild(this.cropper);
      removeClass(this.element, CLASS_HIDDEN);
    }
  }, {
    key: "uncreate",
    value: function uncreate() {
      if (this.ready) {
        this.unbuild();
        this.ready = false;
        this.cropped = false;
      } else if (this.sizing) {
        this.sizingImage.onload = null;
        this.sizing = false;
        this.sized = false;
      } else if (this.reloading) {
        this.xhr.onabort = null;
        this.xhr.abort();
      } else if (this.image) {
        this.stop();
      }
    }
    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */

  }], [{
    key: "noConflict",
    value: function noConflict() {
      window.Cropper = AnotherCropper;
      return Cropper;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */

  }, {
    key: "setDefaults",
    value: function setDefaults(options) {
      assign(DEFAULTS, isPlainObject(options) && options);
    }
  }]);

  return Cropper;
}();

assign(Cropper.prototype, render, preview, events, handlers, change, methods);

/* Users/peterallen/Projects/gradio/js/image/interactive/Cropper.svelte generated by Svelte v4.0.0 */
const file$4 = "Users/peterallen/Projects/gradio/js/image/interactive/Cropper.svelte";

function create_fragment$5(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file$4, 32, 0, 600);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			/*img_binding*/ ctx[4](img);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*image*/ 1 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			/*img_binding*/ ctx[4](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Cropper', slots, []);
	let { image } = $$props;
	let el;
	const dispatch = createEventDispatcher();
	let cropper;

	function destroy() {
		cropper.destroy();
	}

	function create() {
		if (cropper) {
			destroy();
		}

		cropper = new Cropper(el,
		{
				autoCropArea: 1,
				cropend() {
					const image_data = cropper.getCroppedCanvas().toDataURL();
					dispatch("crop", image_data);
				}
			});

		dispatch("crop", image);
	}

	$$self.$$.on_mount.push(function () {
		if (image === undefined && !('image' in $$props || $$self.$$.bound[$$self.$$.props['image']])) {
			console.warn("<Cropper> was created without expected prop 'image'");
		}
	});

	const writable_props = ['image'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cropper> was created with unknown prop '${key}'`);
	});

	function img_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('image' in $$props) $$invalidate(0, image = $$props.image);
	};

	$$self.$capture_state = () => ({
		Cropper,
		onMount,
		createEventDispatcher,
		image,
		el,
		dispatch,
		cropper,
		destroy,
		create
	});

	$$self.$inject_state = $$props => {
		if ('image' in $$props) $$invalidate(0, image = $$props.image);
		if ('el' in $$props) $$invalidate(1, el = $$props.el);
		if ('cropper' in $$props) cropper = $$props.cropper;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [image, el, destroy, create, img_binding];
}

class Cropper_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { image: 0, destroy: 2, create: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cropper_1",
			options,
			id: create_fragment$5.name
		});
	}

	get image() {
		return this.$$.ctx[0];
	}

	set image(image) {
		this.$$set({ image });
		flush();
	}

	get destroy() {
		return this.$$.ctx[2];
	}

	set destroy(value) {
		throw new Error("<Cropper>: Cannot set read-only property 'destroy'");
	}

	get create() {
		return this.$$.ctx[3];
	}

	set create(value) {
		throw new Error("<Cropper>: Cannot set read-only property 'create'");
	}
}

class Point {
  /**
   *
   * @param {number} x
   * @param {number} y
   */
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class LazyPoint extends Point {
  /**
   * Update the x and y values
   *
   * @param {Point} point
   */
  update (point) {
    this.x = point.x;
    this.y = point.y;
  }

  /**
   * Move the point to another position using an angle and distance
   *
   * @param {number} angle The angle in radians
   * @param {number} distance How much the point should be moved
   */
  moveByAngle (angle, distance) {
    // Rotate the angle based on the browser coordinate system ([0,0] in the top left)
    const angleRotated = angle + (Math.PI / 2);

    this.x = this.x + (Math.sin(angleRotated) * distance),
    this.y = this.y - (Math.cos(angleRotated) * distance);
  }

  /**
   * Check if this point is the same as another point
   *
   * @param {Point} point
   * @returns {boolean}
   */
  equalsTo (point) {
    return this.x === point.x && this.y === point.y
  }

  /**
   * Get the difference for x and y axis to another point
   *
   * @param {Point} point
   * @returns {Point}
   */
  getDifferenceTo (point) {
    return new Point(this.x - point.x, this.y - point.y)
  }

  /**
   * Calculate distance to another point
   *
   * @param {Point} point
   * @returns {Point}
   */
  getDistanceTo (point) {
    const diff = this.getDifferenceTo(point);

    return Math.sqrt(Math.pow(diff.x, 2) + Math.pow(diff.y, 2))
  }

  /**
   * Calculate the angle to another point
   *
   * @param {Point} point
   * @returns {Point}
   */
  getAngleTo (point) {
    const diff = this.getDifferenceTo(point);

    return Math.atan2(diff.y, diff.x)
  }

  /**
   * Return a simple object with x and y properties
   *
   * @returns {object}
   */
  toObject () {
    return {
      x: this.x,
      y: this.y
    }
  }
}

const RADIUS_DEFAULT = 30;

class LazyBrush {
  /**
   * constructor
   *
   * @param {object} settings
   * @param {number} settings.radius The radius for the lazy area
   * @param {boolean} settings.enabled
   */
  constructor ({ radius = RADIUS_DEFAULT, enabled = true, initialPoint = { x: 0, y: 0 }} = {}) {
    this.radius = radius;
    this._isEnabled = enabled;

    this.pointer = new LazyPoint(initialPoint.x, initialPoint.y);
    this.brush = new LazyPoint(initialPoint.x, initialPoint.y);

    this.angle = 0;
    this.distance = 0;
    this._hasMoved = false;
  }

  /**
   * Enable lazy brush calculations.
   *
   */
  enable () {
    this._isEnabled = true;
  }

  /**
   * Disable lazy brush calculations.
   *
   */
  disable () {
    this._isEnabled = false;
  }

  /**
   * @returns {boolean}
   */
  isEnabled () {
    return this._isEnabled
  }

  /**
   * Update the radius
   *
   * @param {number} radius
   */
  setRadius (radius) {
    this.radius = radius;
  }

  /**
   * Return the current radius
   *
   * @returns {number}
   */
  getRadius () {
    return this.radius
  }

  /**
   * Return the brush coordinates as a simple object
   *
   * @returns {object}
   */
  getBrushCoordinates () {
    return this.brush.toObject()
  }

  /**
   * Return the pointer coordinates as a simple object
   *
   * @returns {object}
   */
  getPointerCoordinates () {
    return this.pointer.toObject()
  }

  /**
   * Return the brush as a LazyPoint
   *
   * @returns {LazyPoint}
   */
  getBrush () {
    return this.brush
  }

  /**
   * Return the pointer as a LazyPoint
   *
   * @returns {LazyPoint}
   */
  getPointer () {
    return this.pointer
  }

  /**
   * Return the angle between pointer and brush
   *
   * @returns {number} Angle in radians
   */
  getAngle () {
    return this.angle
  }

  /**
   * Return the distance between pointer and brush
   *
   * @returns {number} Distance in pixels
   */
  getDistance () {
    return this.distance
  }

  /**
   * Return if the previous update has moved the brush.
   *
   * @returns {boolean} Whether the brush moved previously.
   */
  brushHasMoved () {
    return this._hasMoved
  }

  /**
   * Updates the pointer point and calculates the new brush point.
   *
   * @param {Point} newPointerPoint
   * @param {Object} options
   * @param {Boolean} options.both Force update pointer and brush
   * @returns {Boolean} Whether any of the two points changed
   */
  update (newPointerPoint, { both = false } = {}) {
    this._hasMoved = false;
    if (this.pointer.equalsTo(newPointerPoint) && !both) {
      return false
    }

    this.pointer.update(newPointerPoint);

    if (both) {
      this._hasMoved = true;
      this.brush.update(newPointerPoint);
      return true
    }

    if (this._isEnabled) {
      this.distance = this.pointer.getDistanceTo(this.brush);
      this.angle = this.pointer.getAngleTo(this.brush);

      if (this.distance > this.radius) {
        this.brush.moveByAngle(this.angle, this.distance - this.radius);
        this._hasMoved = true;
      }
    } else {
      this.distance = 0;
      this.angle = 0;
      this.brush.update(newPointerPoint);
      this._hasMoved = true;
    }

    return true
  }
}

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

const Sketch_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/image/interactive/Sketch.svelte generated by Svelte v4.0.0 */

const { Object: Object_1, console: console_1 } = globals;
const file$3 = "Users/peterallen/Projects/gradio/js/image/interactive/Sketch.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[62] = list[i].name;
	child_ctx[63] = list[i].zIndex;
	child_ctx[64] = list[i].opacity;
	child_ctx[65] = list;
	child_ctx[66] = i;
	return child_ctx;
}

// (553:1) {#if line_count === 0}
function create_if_block$3(ctx) {
	let div;
	let div_transition;
	let current;

	const block = {
		c: function create() {
			div = element("div");
			div.textContent = "Start drawing";
			attr_dev(div, "class", "start-prompt s-7y17MFEldt3f");
			add_location(div, file$3, 553, 2, 11714);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (!current) return;
					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 50 }, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 50 }, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(553:1) {#if line_count === 0}",
		ctx
	});

	return block;
}

// (558:1) {#each canvas_types as { name, zIndex, opacity }}
function create_each_block(ctx) {
	let canvas_1;
	let name = /*name*/ ctx[62];
	let mounted;
	let dispose;
	const assign_canvas_1 = () => /*canvas_1_binding*/ ctx[31](canvas_1, name);
	const unassign_canvas_1 = () => /*canvas_1_binding*/ ctx[31](null, name);

	const block = {
		c: function create() {
			canvas_1 = element("canvas");
			attr_dev(canvas_1, "key", /*name*/ ctx[62]);
			set_style(canvas_1, "z-index", /*zIndex*/ ctx[63]);
			attr_dev(canvas_1, "class", "s-7y17MFEldt3f");
			toggle_class(canvas_1, "lr", /*add_lr_border*/ ctx[5]);
			toggle_class(canvas_1, "tb", !/*add_lr_border*/ ctx[5]);
			set_style(canvas_1, "opacity", /*opacity*/ ctx[64]);
			add_location(canvas_1, file$3, 558, 2, 11862);
		},
		m: function mount(target, anchor) {
			insert_dev(target, canvas_1, anchor);
			assign_canvas_1();

			if (!mounted) {
				dispose = [
					listen_dev(
						canvas_1,
						"mousedown",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_start*/ ctx[7]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"mousemove",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_move*/ ctx[8]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"mouseup",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_end*/ ctx[9]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"mouseout",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_end*/ ctx[9]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"blur",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_end*/ ctx[9]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"touchstart",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_start*/ ctx[7]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"touchmove",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_move*/ ctx[8]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"touchend",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_end*/ ctx[9]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(
						canvas_1,
						"touchcancel",
						/*name*/ ctx[62] === "interface"
						? /*handle_draw_end*/ ctx[9]
						: undefined,
						false,
						false,
						false,
						false
					),
					listen_dev(canvas_1, "click", stop_propagation(/*click_handler*/ ctx[30]), false, false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (name !== /*name*/ ctx[62]) {
				unassign_canvas_1();
				name = /*name*/ ctx[62];
				assign_canvas_1();
			}

			if (dirty[0] & /*add_lr_border*/ 32) {
				toggle_class(canvas_1, "lr", /*add_lr_border*/ ctx[5]);
			}

			if (dirty[0] & /*add_lr_border*/ 32) {
				toggle_class(canvas_1, "tb", !/*add_lr_border*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(canvas_1);
			}

			unassign_canvas_1();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(558:1) {#each canvas_types as { name, zIndex, opacity }}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let t;
	let div_resize_listener;
	let if_block = /*line_count*/ ctx[4] === 0 && create_if_block$3(ctx);
	let each_value = ensure_array_like_dev(/*canvas_types*/ ctx[6]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "wrap s-7y17MFEldt3f");
			add_render_callback(() => /*div_elementresize_handler*/ ctx[33].call(div));
			add_location(div, file$3, 546, 0, 11569);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			/*div_binding*/ ctx[32](div);
			div_resize_listener = add_iframe_resize_listener(div, /*div_elementresize_handler*/ ctx[33].bind(div));
		},
		p: function update(ctx, dirty) {
			if (/*line_count*/ ctx[4] === 0) {
				if (if_block) {
					if (dirty[0] & /*line_count*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*canvas_types, canvas, add_lr_border, handle_draw_start, handle_draw_move, handle_draw_end*/ 993) {
				each_value = ensure_array_like_dev(/*canvas_types*/ ctx[6]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: function outro(local) {
			transition_out(if_block);
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			/*div_binding*/ ctx[32](null);
			div_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function mid_point(p1, p2) {
	return {
		x: p1.x + (p2.x - p1.x) / 2,
		y: p1.y + (p2.y - p1.y) / 2
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let brush_dot;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sketch', slots, []);
	const dispatch = createEventDispatcher();
	let { value } = $$props;
	let { value_img } = $$props;
	let { mode = "sketch" } = $$props;
	let { brush_color = "#0b0f19" } = $$props;
	let { brush_radius } = $$props;
	let { mask_opacity = 0.7 } = $$props;
	let { source } = $$props;
	let { width = 400 } = $$props;
	let { height = 200 } = $$props;
	let { container_height = 200 } = $$props;
	let { shape } = $$props;
	let mounted;
	let catenary_color = "#aaa";
	let canvas_width = width;
	let canvas_height = height;
	let last_value_img;

	const canvas_types = [
		{ name: "interface", zIndex: 15 },
		{
			name: "mask",
			zIndex: 13,
			opacity: mask_opacity
		},
		{ name: "drawing", zIndex: 11 },
		{ name: "temp", zIndex: 12 }
	];

	let canvas = {};
	let ctx = {};
	let points = [];
	let lines = [];
	let mouse_has_moved = true;
	let values_changed = true;
	let is_drawing = false;
	let is_pressing = false;
	let lazy = null;
	let canvas_container = null;
	let canvas_observer = null;
	let line_count = 0;

	function draw_cropped_image() {
		if (!shape) {
			ctx.temp.drawImage(value_img, 0, 0, width, height);
			return;
		}

		let _width = value_img.naturalWidth;
		let _height = value_img.naturalHeight;
		const shape_ratio = shape[0] / shape[1];
		const image_ratio = _width / _height;
		let x = 0;
		let y = 0;

		if (shape_ratio < image_ratio) {
			_width = shape[1] * image_ratio;
			_height = shape[1];
			x = (shape[0] - _width) / 2;
		} else if (shape_ratio > image_ratio) {
			_width = shape[0];
			_height = shape[0] / image_ratio;
			y = (shape[1] - _height) / 2;
		} else {
			x = 0;
			y = 0;
			_width = shape[0];
			_height = shape[1];
		}

		ctx.temp.drawImage(value_img, x, y, _width, _height);
	}

	onMount(async () => {
		Object.keys(canvas).forEach(key => {
			$$invalidate(27, ctx[key] = canvas[key].getContext("2d"), ctx);
		});

		await tick();

		if (value_img) {
			value_img.addEventListener("load", _ => {
				if (source === "webcam") {
					ctx.temp.save();
					ctx.temp.translate(width, 0);
					ctx.temp.scale(-1, 1);
					ctx.temp.drawImage(value_img, 0, 0);
					ctx.temp.restore();
				} else {
					draw_cropped_image();
				}

				ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);
				trigger_on_change();
			});

			setTimeout(
				() => {
					if (source === "webcam") {
						ctx.temp.save();
						ctx.temp.translate(width, 0);
						ctx.temp.scale(-1, 1);
						ctx.temp.drawImage(value_img, 0, 0);
						ctx.temp.restore();
					} else {
						draw_cropped_image();
					}

					ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);
					draw_lines({ lines: lines.slice() });
					trigger_on_change();
				},
				100
			);
		}

		$$invalidate(29, lazy = new LazyBrush({
				radius: brush_radius * 0.05,
				enabled: true,
				initialPoint: { x: width / 2, y: height / 2 }
			}));

		canvas_observer = new index((entries, observer, ...rest) => {
				handle_canvas_resize(entries, observer);
			});

		canvas_observer.observe(canvas_container);
		loop();
		$$invalidate(25, mounted = true);

		requestAnimationFrame(() => {
			init();

			requestAnimationFrame(() => {
				clear();
			});
		});
	});

	function init() {
		const initX = width / 2;
		const initY = height / 2;
		lazy.update({ x: initX, y: initY }, { both: true });
		lazy.update({ x: initX, y: initY }, { both: false });
		mouse_has_moved = true;
		values_changed = true;
	}

	onDestroy(() => {
		$$invalidate(25, mounted = false);
		canvas_observer.unobserve(canvas_container);
	});

	function redraw_image(_lines) {
		clear_canvas();

		if (value_img) {
			if (source === "webcam") {
				ctx.temp.save();
				ctx.temp.translate(width, 0);
				ctx.temp.scale(-1, 1);
				ctx.temp.drawImage(value_img, 0, 0);
				ctx.temp.restore();
			} else {
				draw_cropped_image();
			}

			if (!lines || !lines.length) {
				ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);
			}
		}

		draw_lines({ lines: _lines });
		$$invalidate(4, line_count = _lines.length);
		$$invalidate(28, lines = _lines);
		ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);

		if (lines.length == 0) {
			dispatch("clear");
		}
	}

	function clear_mask() {
		const _lines = [];
		redraw_image(_lines);
		trigger_on_change();
	}

	function undo() {
		const _lines = lines.slice(0, -1);
		redraw_image(_lines);
		trigger_on_change();
	}

	let get_save_data = () => {
		return JSON.stringify({
			lines,
			width: canvas_width,
			height: canvas_height
		});
	};

	let draw_lines = ({ lines }) => {
		lines.forEach(line => {
			const { points: _points, brush_color, brush_radius } = line;

			draw_points({
				points: _points,
				brush_color,
				brush_radius,
				mask: mode === "mask"
			});
		});

		saveLine({ brush_color, brush_radius });

		if (mode === "mask") {
			save_mask_line();
		}
	};

	let handle_draw_start = e => {
		e.preventDefault();
		is_pressing = true;
		const { x, y } = get_pointer_pos(e);

		if (e.touches && e.touches.length > 0) {
			lazy.update({ x, y }, { both: true });
		}

		handle_pointer_move(x, y);
		$$invalidate(4, line_count += 1);
	};

	let handle_draw_move = e => {
		e.preventDefault();
		const { x, y } = get_pointer_pos(e);
		handle_pointer_move(x, y);
	};

	let handle_draw_end = e => {
		e.preventDefault();
		handle_draw_move(e);
		is_drawing = false;
		is_pressing = false;
		saveLine();

		if (mode === "mask") {
			save_mask_line();
		}
	};

	let old_width = 0;
	let old_height = 0;
	let old_container_height = 0;
	let add_lr_border = false;

	let handle_canvas_resize = async () => {
		if (shape && canvas_container) {
			const x = canvas_container?.getBoundingClientRect();
			const shape_ratio = shape[0] / shape[1];
			const container_ratio = x.width / x.height;
			$$invalidate(5, add_lr_border = shape_ratio < container_ratio);
		}

		if (width === old_width && height === old_height && old_container_height === container_height) {
			return;
		}

		const dimensions = { width, height };

		const container_dimensions = {
			height: container_height,
			width: container_height * (dimensions.width / dimensions.height)
		};

		await Promise.all([
			set_canvas_size(canvas.interface, dimensions, container_dimensions),
			set_canvas_size(canvas.drawing, dimensions, container_dimensions),
			set_canvas_size(canvas.temp, dimensions, container_dimensions),
			set_canvas_size(canvas.mask, dimensions, container_dimensions, false)
		]);

		if (!brush_radius) {
			$$invalidate(10, brush_radius = 20 * (dimensions.width / container_dimensions.width));
		}

		loop({ once: true });

		setTimeout(
			() => {
				old_height = height;
				old_width = width;
				old_container_height = container_height;
			},
			10
		);

		await tick();
		clear();
	};

	let set_canvas_size = async (canvas, dimensions, container, scale = true) => {
		if (!mounted) return;
		await tick();
		const dpr = window.devicePixelRatio || 1;
		canvas.width = dimensions.width * (scale ? dpr : 1);
		canvas.height = dimensions.height * (scale ? dpr : 1);
		const ctx = canvas.getContext("2d");
		scale && ctx.scale(dpr, dpr);
		canvas.style.width = `${container.width}px`;
		canvas.style.height = `${container.height}px`;
	};

	let get_pointer_pos = e => {
		const rect = canvas.interface.getBoundingClientRect();
		let clientX = e.clientX;
		let clientY = e.clientY;

		if (e.changedTouches && e.changedTouches.length > 0) {
			clientX = e.changedTouches[0].clientX;
			clientY = e.changedTouches[0].clientY;
		}

		return {
			x: (clientX - rect.left) / rect.width * width,
			y: (clientY - rect.top) / rect.height * height
		};
	};

	let handle_pointer_move = (x, y) => {
		lazy.update({ x, y });
		const is_disabled = !lazy.isEnabled();

		if (is_pressing && !is_drawing || is_disabled && is_pressing) {
			is_drawing = true;
			points.push(lazy.brush.toObject());
		}

		if (is_drawing) {
			points.push(lazy.brush.toObject());

			draw_points({
				points,
				brush_color,
				brush_radius,
				mask: mode === "mask"
			});
		}

		mouse_has_moved = true;
	};

	let draw_points = ({ points, brush_color, brush_radius, mask }) => {
		if (!points || points.length < 2) return;
		let target_ctx = mask ? ctx.mask : ctx.temp;
		target_ctx.lineJoin = "round";
		target_ctx.lineCap = "round";
		target_ctx.strokeStyle = brush_color;
		target_ctx.lineWidth = brush_radius;
		let p1 = points[0];
		let p2 = points[1];
		target_ctx.moveTo(p2.x, p2.y);
		target_ctx.beginPath();

		for (var i = 1, len = points.length; i < len; i++) {
			var midPoint = mid_point(p1, p2);
			target_ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
			p1 = points[i];
			p2 = points[i + 1];
		}

		target_ctx.lineTo(p1.x, p1.y);
		target_ctx.stroke();
	};

	let save_mask_line = () => {
		if (points.length < 1) return;
		points.length = 0;
		trigger_on_change();
	};

	let saveLine = () => {
		if (points.length < 1) return;

		lines.push({
			points: points.slice(),
			brush_color,
			brush_radius
		});

		if (mode !== "mask") {
			points.length = 0;
		}

		ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);
		trigger_on_change();
	};

	let trigger_on_change = () => {
		const x = get_image_data();
		dispatch("change", x);
	};

	function clear() {
		$$invalidate(28, lines = []);
		clear_canvas();
		$$invalidate(4, line_count = 0);
		return true;
	}

	function clear_canvas() {
		values_changed = true;
		ctx.temp.clearRect(0, 0, width, height);
		$$invalidate(27, ctx.temp.fillStyle = mode === "mask" ? "transparent" : "#FFFFFF", ctx);
		ctx.temp.fillRect(0, 0, width, height);

		if (mode === "mask") {
			ctx.mask.clearRect(0, 0, canvas.mask.width, canvas.mask.height);
		}
	}

	let loop = ({ once = false } = {}) => {
		if (mouse_has_moved || values_changed) {
			const pointer = lazy.getPointerCoordinates();
			const brush = lazy.getBrushCoordinates();
			draw_interface(ctx.interface, pointer, brush);
			mouse_has_moved = false;
			values_changed = false;
		}

		if (!once) {
			window.requestAnimationFrame(() => {
				loop();
			});
		}
	};

	let draw_interface = (ctx, pointer, brush) => {
		ctx.clearRect(0, 0, width, height);

		// brush preview
		ctx.beginPath();

		ctx.fillStyle = brush_color;
		ctx.arc(brush.x, brush.y, brush_radius / 2, 0, Math.PI * 2, true);
		ctx.fill();

		// tiny brush point dot
		ctx.beginPath();

		ctx.fillStyle = catenary_color;
		ctx.arc(brush.x, brush.y, brush_dot, 0, Math.PI * 2, true);
		ctx.fill();
	};

	function get_image_data() {
		return mode === "mask"
		? canvas.mask.toDataURL("image/png")
		: canvas.drawing.toDataURL("image/jpg");
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console_1.warn("<Sketch> was created without expected prop 'value'");
		}

		if (value_img === undefined && !('value_img' in $$props || $$self.$$.bound[$$self.$$.props['value_img']])) {
			console_1.warn("<Sketch> was created without expected prop 'value_img'");
		}

		if (brush_radius === undefined && !('brush_radius' in $$props || $$self.$$.bound[$$self.$$.props['brush_radius']])) {
			console_1.warn("<Sketch> was created without expected prop 'brush_radius'");
		}

		if (source === undefined && !('source' in $$props || $$self.$$.bound[$$self.$$.props['source']])) {
			console_1.warn("<Sketch> was created without expected prop 'source'");
		}

		if (shape === undefined && !('shape' in $$props || $$self.$$.bound[$$self.$$.props['shape']])) {
			console_1.warn("<Sketch> was created without expected prop 'shape'");
		}
	});

	const writable_props = [
		'value',
		'value_img',
		'mode',
		'brush_color',
		'brush_radius',
		'mask_opacity',
		'source',
		'width',
		'height',
		'container_height',
		'shape'
	];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Sketch> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function canvas_1_binding($$value, name) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas[name] = $$value;
			$$invalidate(0, canvas);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas_container = $$value;
			$$invalidate(3, canvas_container);
		});
	}

	function div_elementresize_handler() {
		canvas_width = this.offsetWidth;
		canvas_height = this.offsetHeight;
		$$invalidate(1, canvas_width);
		$$invalidate(2, canvas_height);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(13, value = $$props.value);
		if ('value_img' in $$props) $$invalidate(14, value_img = $$props.value_img);
		if ('mode' in $$props) $$invalidate(15, mode = $$props.mode);
		if ('brush_color' in $$props) $$invalidate(16, brush_color = $$props.brush_color);
		if ('brush_radius' in $$props) $$invalidate(10, brush_radius = $$props.brush_radius);
		if ('mask_opacity' in $$props) $$invalidate(17, mask_opacity = $$props.mask_opacity);
		if ('source' in $$props) $$invalidate(18, source = $$props.source);
		if ('width' in $$props) $$invalidate(11, width = $$props.width);
		if ('height' in $$props) $$invalidate(12, height = $$props.height);
		if ('container_height' in $$props) $$invalidate(19, container_height = $$props.container_height);
		if ('shape' in $$props) $$invalidate(20, shape = $$props.shape);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		tick,
		fade,
		LazyBrush,
		ResizeObserver: index,
		dispatch,
		value,
		value_img,
		mode,
		brush_color,
		brush_radius,
		mask_opacity,
		source,
		width,
		height,
		container_height,
		shape,
		mounted,
		catenary_color,
		canvas_width,
		canvas_height,
		last_value_img,
		mid_point,
		canvas_types,
		canvas,
		ctx,
		points,
		lines,
		mouse_has_moved,
		values_changed,
		is_drawing,
		is_pressing,
		lazy,
		canvas_container,
		canvas_observer,
		line_count,
		draw_cropped_image,
		init,
		redraw_image,
		clear_mask,
		undo,
		get_save_data,
		draw_lines,
		handle_draw_start,
		handle_draw_move,
		handle_draw_end,
		old_width,
		old_height,
		old_container_height,
		add_lr_border,
		handle_canvas_resize,
		set_canvas_size,
		get_pointer_pos,
		handle_pointer_move,
		draw_points,
		save_mask_line,
		saveLine,
		trigger_on_change,
		clear,
		clear_canvas,
		loop,
		draw_interface,
		get_image_data,
		brush_dot
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(13, value = $$props.value);
		if ('value_img' in $$props) $$invalidate(14, value_img = $$props.value_img);
		if ('mode' in $$props) $$invalidate(15, mode = $$props.mode);
		if ('brush_color' in $$props) $$invalidate(16, brush_color = $$props.brush_color);
		if ('brush_radius' in $$props) $$invalidate(10, brush_radius = $$props.brush_radius);
		if ('mask_opacity' in $$props) $$invalidate(17, mask_opacity = $$props.mask_opacity);
		if ('source' in $$props) $$invalidate(18, source = $$props.source);
		if ('width' in $$props) $$invalidate(11, width = $$props.width);
		if ('height' in $$props) $$invalidate(12, height = $$props.height);
		if ('container_height' in $$props) $$invalidate(19, container_height = $$props.container_height);
		if ('shape' in $$props) $$invalidate(20, shape = $$props.shape);
		if ('mounted' in $$props) $$invalidate(25, mounted = $$props.mounted);
		if ('catenary_color' in $$props) catenary_color = $$props.catenary_color;
		if ('canvas_width' in $$props) $$invalidate(1, canvas_width = $$props.canvas_width);
		if ('canvas_height' in $$props) $$invalidate(2, canvas_height = $$props.canvas_height);
		if ('last_value_img' in $$props) $$invalidate(26, last_value_img = $$props.last_value_img);
		if ('canvas' in $$props) $$invalidate(0, canvas = $$props.canvas);
		if ('ctx' in $$props) $$invalidate(27, ctx = $$props.ctx);
		if ('points' in $$props) points = $$props.points;
		if ('lines' in $$props) $$invalidate(28, lines = $$props.lines);
		if ('mouse_has_moved' in $$props) mouse_has_moved = $$props.mouse_has_moved;
		if ('values_changed' in $$props) values_changed = $$props.values_changed;
		if ('is_drawing' in $$props) is_drawing = $$props.is_drawing;
		if ('is_pressing' in $$props) is_pressing = $$props.is_pressing;
		if ('lazy' in $$props) $$invalidate(29, lazy = $$props.lazy);
		if ('canvas_container' in $$props) $$invalidate(3, canvas_container = $$props.canvas_container);
		if ('canvas_observer' in $$props) canvas_observer = $$props.canvas_observer;
		if ('line_count' in $$props) $$invalidate(4, line_count = $$props.line_count);
		if ('get_save_data' in $$props) get_save_data = $$props.get_save_data;
		if ('draw_lines' in $$props) $$invalidate(50, draw_lines = $$props.draw_lines);
		if ('handle_draw_start' in $$props) $$invalidate(7, handle_draw_start = $$props.handle_draw_start);
		if ('handle_draw_move' in $$props) $$invalidate(8, handle_draw_move = $$props.handle_draw_move);
		if ('handle_draw_end' in $$props) $$invalidate(9, handle_draw_end = $$props.handle_draw_end);
		if ('old_width' in $$props) old_width = $$props.old_width;
		if ('old_height' in $$props) old_height = $$props.old_height;
		if ('old_container_height' in $$props) old_container_height = $$props.old_container_height;
		if ('add_lr_border' in $$props) $$invalidate(5, add_lr_border = $$props.add_lr_border);
		if ('handle_canvas_resize' in $$props) $$invalidate(51, handle_canvas_resize = $$props.handle_canvas_resize);
		if ('set_canvas_size' in $$props) set_canvas_size = $$props.set_canvas_size;
		if ('get_pointer_pos' in $$props) get_pointer_pos = $$props.get_pointer_pos;
		if ('handle_pointer_move' in $$props) handle_pointer_move = $$props.handle_pointer_move;
		if ('draw_points' in $$props) draw_points = $$props.draw_points;
		if ('save_mask_line' in $$props) save_mask_line = $$props.save_mask_line;
		if ('saveLine' in $$props) saveLine = $$props.saveLine;
		if ('trigger_on_change' in $$props) $$invalidate(58, trigger_on_change = $$props.trigger_on_change);
		if ('loop' in $$props) loop = $$props.loop;
		if ('draw_interface' in $$props) draw_interface = $$props.draw_interface;
		if ('brush_dot' in $$props) brush_dot = $$props.brush_dot;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*shape, width, height*/ 1054720) {
			{
				if (shape && (width || height)) {
					$$invalidate(11, width = shape[0]);
					$$invalidate(12, height = shape[1]);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*mounted, value*/ 33562624) {
			mounted && !value && clear();
		}

		if ($$self.$$.dirty[0] & /*value_img*/ 16384) {
			console.log(value_img);
		}

		if ($$self.$$.dirty[0] & /*mounted, value_img, last_value_img, source, ctx, width, canvas, height, lines*/ 503601153) {
			{
				if (mounted && value_img !== last_value_img) {
					$$invalidate(26, last_value_img = value_img);
					clear();

					setTimeout(
						() => {
							if (source === "webcam") {
								ctx.temp.save();
								ctx.temp.translate(width, 0);
								ctx.temp.scale(-1, 1);
								ctx.temp.drawImage(value_img, 0, 0);
								ctx.temp.restore();
							} else {
								draw_cropped_image();
							}

							ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);
							draw_lines({ lines: lines.slice() });
							trigger_on_change();
						},
						50
					);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*lazy, brush_radius*/ 536871936) {
			{
				if (lazy) {
					init();
					lazy.setRadius(brush_radius * 0.05);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*width, height*/ 6144) {
			{
				if (width || height) {
					handle_canvas_resize();
				}
			}
		}

		if ($$self.$$.dirty[0] & /*brush_radius*/ 1024) {
			brush_dot = brush_radius * 0.075;
		}
	};

	return [
		canvas,
		canvas_width,
		canvas_height,
		canvas_container,
		line_count,
		add_lr_border,
		canvas_types,
		handle_draw_start,
		handle_draw_move,
		handle_draw_end,
		brush_radius,
		width,
		height,
		value,
		value_img,
		mode,
		brush_color,
		mask_opacity,
		source,
		container_height,
		shape,
		clear_mask,
		undo,
		clear,
		get_image_data,
		mounted,
		last_value_img,
		ctx,
		lines,
		lazy,
		click_handler,
		canvas_1_binding,
		div_binding,
		div_elementresize_handler
	];
}

class Sketch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$4,
			create_fragment$4,
			safe_not_equal,
			{
				value: 13,
				value_img: 14,
				mode: 15,
				brush_color: 16,
				brush_radius: 10,
				mask_opacity: 17,
				source: 18,
				width: 11,
				height: 12,
				container_height: 19,
				shape: 20,
				clear_mask: 21,
				undo: 22,
				clear: 23,
				get_image_data: 24
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sketch",
			options,
			id: create_fragment$4.name
		});
	}

	get value() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value_img() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value_img(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brush_color() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_color(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brush_radius() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_radius(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mask_opacity() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mask_opacity(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get source() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set source(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container_height() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container_height(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shape() {
		throw new Error("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shape(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear_mask() {
		return this.$$.ctx[21];
	}

	set clear_mask(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get undo() {
		return this.$$.ctx[22];
	}

	set undo(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear() {
		return this.$$.ctx[23];
	}

	set clear(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get get_image_data() {
		return this.$$.ctx[24];
	}

	set get_image_data(value) {
		throw new Error("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const ModifySketch_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/image/interactive/ModifySketch.svelte generated by Svelte v4.0.0 */
const file$2 = "Users/peterallen/Projects/gradio/js/image/interactive/ModifySketch.svelte";

// (11:1) {#if show_eraser}
function create_if_block$2(ctx) {
	let iconbutton;
	let current;

	iconbutton = new IconButton({
			props: { Icon: Erase, label: "Clear" },
			$$inline: true
		});

	iconbutton.$on("click", /*click_handler_1*/ ctx[3]);

	const block = {
		c: function create() {
			create_component(iconbutton.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(11:1) {#if show_eraser}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let iconbutton0;
	let t0;
	let t1;
	let iconbutton1;
	let current;

	iconbutton0 = new IconButton({
			props: { Icon: Undo, label: "Undo" },
			$$inline: true
		});

	iconbutton0.$on("click", /*click_handler*/ ctx[2]);
	let if_block = /*show_eraser*/ ctx[0] && create_if_block$2(ctx);

	iconbutton1 = new IconButton({
			props: { Icon: Clear, label: "Remove Image" },
			$$inline: true
		});

	iconbutton1.$on("click", /*click_handler_2*/ ctx[4]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(iconbutton0.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(iconbutton1.$$.fragment);
			attr_dev(div, "class", "s-d7kaOL1pq9zc");
			add_location(div, file$2, 10, 0, 247);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(iconbutton0, div, null);
			append_dev(div, t0);
			if (if_block) if_block.m(div, null);
			append_dev(div, t1);
			mount_component(iconbutton1, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*show_eraser*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*show_eraser*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton0.$$.fragment, local);
			transition_in(if_block);
			transition_in(iconbutton1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(if_block);
			transition_out(iconbutton1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(iconbutton0);
			if (if_block) if_block.d();
			destroy_component(iconbutton1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ModifySketch', slots, []);
	const dispatch = createEventDispatcher();
	let { show_eraser = false } = $$props;
	const writable_props = ['show_eraser'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ModifySketch> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch("undo");

	const click_handler_1 = event => {
		dispatch("clear_mask");
		event.stopPropagation();
	};

	const click_handler_2 = event => {
		dispatch("remove_image");
		event.stopPropagation();
	};

	$$self.$$set = $$props => {
		if ('show_eraser' in $$props) $$invalidate(0, show_eraser = $$props.show_eraser);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		IconButton,
		Undo,
		Clear,
		Erase,
		dispatch,
		show_eraser
	});

	$$self.$inject_state = $$props => {
		if ('show_eraser' in $$props) $$invalidate(0, show_eraser = $$props.show_eraser);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [show_eraser, dispatch, click_handler, click_handler_1, click_handler_2];
}

class ModifySketch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { show_eraser: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ModifySketch",
			options,
			id: create_fragment$3.name
		});
	}

	get show_eraser() {
		throw new Error("<ModifySketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_eraser(value) {
		throw new Error("<ModifySketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const SketchSettings_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/image/interactive/SketchSettings.svelte generated by Svelte v4.0.0 */
const file$1 = "Users/peterallen/Projects/gradio/js/image/interactive/SketchSettings.svelte";

// (21:2) {#if show_size}
function create_if_block_2$1(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "aria-label", "Brush radius");
			attr_dev(input, "type", "range");
			attr_dev(input, "min", input_min_value = 0.5 * (/*img_width*/ ctx[2] / /*width*/ ctx[6]));
			attr_dev(input, "max", input_max_value = 75 * (/*img_width*/ ctx[2] / /*width*/ ctx[6]));
			attr_dev(input, "class", "s-clpouhq3Q_BP");
			add_location(input, file$1, 25, 3, 547);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*brush_radius*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_input_handler*/ ctx[10]),
					listen_dev(input, "input", /*input_change_input_handler*/ ctx[10])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*img_width, width*/ 68 && input_min_value !== (input_min_value = 0.5 * (/*img_width*/ ctx[2] / /*width*/ ctx[6]))) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*img_width, width*/ 68 && input_max_value !== (input_max_value = 75 * (/*img_width*/ ctx[2] / /*width*/ ctx[6]))) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*brush_radius*/ 1) {
				set_input_value(input, /*brush_radius*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(input);
			}

			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(21:2) {#if show_size}",
		ctx
	});

	return block;
}

// (32:1) {#if mode !== "mask"}
function create_if_block$1(ctx) {
	let span;
	let iconbutton;
	let t;
	let current;

	iconbutton = new IconButton({
			props: { Icon: Color, label: "Select brush color" },
			$$inline: true
		});

	iconbutton.$on("click", /*click_handler_1*/ ctx[11]);
	let if_block = /*show_col*/ ctx[5] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			span = element("span");
			create_component(iconbutton.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr_dev(span, "class", "col s-clpouhq3Q_BP");
			add_location(span, file$1, 36, 2, 751);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(iconbutton, span, null);
			append_dev(span, t);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*show_col*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}

			destroy_component(iconbutton);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(32:1) {#if mode !== \\\"mask\\\"}",
		ctx
	});

	return block;
}

// (39:3) {#if show_col}
function create_if_block_1$1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "aria-label", "Brush color");
			attr_dev(input, "type", "color");
			attr_dev(input, "class", "s-clpouhq3Q_BP");
			add_location(input, file$1, 43, 4, 905);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*brush_color*/ ctx[1]);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[12]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*brush_color*/ 2) {
				set_input_value(input, /*brush_color*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(input);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(39:3) {#if show_col}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let span;
	let iconbutton;
	let t0;
	let t1;
	let current;

	iconbutton = new IconButton({
			props: { Icon: Brush, label: "Use brush" },
			$$inline: true
		});

	iconbutton.$on("click", /*click_handler*/ ctx[9]);
	let if_block0 = /*show_size*/ ctx[4] && create_if_block_2$1(ctx);
	let if_block1 = /*mode*/ ctx[3] !== "mask" && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			create_component(iconbutton.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr_dev(span, "class", "brush s-clpouhq3Q_BP");
			add_location(span, file$1, 18, 1, 404);
			attr_dev(div, "class", "wrap s-clpouhq3Q_BP");
			add_location(div, file$1, 17, 0, 384);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			mount_component(iconbutton, span, null);
			append_dev(span, t0);
			if (if_block0) if_block0.m(span, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*show_size*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					if_block0.m(span, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*mode*/ ctx[3] !== "mask") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*mode*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(iconbutton);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let width;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SketchSettings', slots, []);
	let show_size = false;
	let show_col = false;
	let { brush_radius = 20 } = $$props;
	let { brush_color = "#000" } = $$props;
	let { container_height } = $$props;
	let { img_width } = $$props;
	let { img_height } = $$props;
	let { mode = "other" } = $$props;

	$$self.$$.on_mount.push(function () {
		if (container_height === undefined && !('container_height' in $$props || $$self.$$.bound[$$self.$$.props['container_height']])) {
			console.warn("<SketchSettings> was created without expected prop 'container_height'");
		}

		if (img_width === undefined && !('img_width' in $$props || $$self.$$.bound[$$self.$$.props['img_width']])) {
			console.warn("<SketchSettings> was created without expected prop 'img_width'");
		}

		if (img_height === undefined && !('img_height' in $$props || $$self.$$.bound[$$self.$$.props['img_height']])) {
			console.warn("<SketchSettings> was created without expected prop 'img_height'");
		}
	});

	const writable_props = [
		'brush_radius',
		'brush_color',
		'container_height',
		'img_width',
		'img_height',
		'mode'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SketchSettings> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(4, show_size = !show_size);

	function input_change_input_handler() {
		brush_radius = to_number(this.value);
		$$invalidate(0, brush_radius);
	}

	const click_handler_1 = () => $$invalidate(5, show_col = !show_col);

	function input_input_handler() {
		brush_color = this.value;
		$$invalidate(1, brush_color);
	}

	$$self.$$set = $$props => {
		if ('brush_radius' in $$props) $$invalidate(0, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(1, brush_color = $$props.brush_color);
		if ('container_height' in $$props) $$invalidate(7, container_height = $$props.container_height);
		if ('img_width' in $$props) $$invalidate(2, img_width = $$props.img_width);
		if ('img_height' in $$props) $$invalidate(8, img_height = $$props.img_height);
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({
		IconButton,
		Brush,
		Color,
		show_size,
		show_col,
		brush_radius,
		brush_color,
		container_height,
		img_width,
		img_height,
		mode,
		width
	});

	$$self.$inject_state = $$props => {
		if ('show_size' in $$props) $$invalidate(4, show_size = $$props.show_size);
		if ('show_col' in $$props) $$invalidate(5, show_col = $$props.show_col);
		if ('brush_radius' in $$props) $$invalidate(0, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(1, brush_color = $$props.brush_color);
		if ('container_height' in $$props) $$invalidate(7, container_height = $$props.container_height);
		if ('img_width' in $$props) $$invalidate(2, img_width = $$props.img_width);
		if ('img_height' in $$props) $$invalidate(8, img_height = $$props.img_height);
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
		if ('width' in $$props) $$invalidate(6, width = $$props.width);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*container_height, img_width, img_height*/ 388) {
			$$invalidate(6, width = container_height * (img_width / img_height));
		}
	};

	return [
		brush_radius,
		brush_color,
		img_width,
		mode,
		show_size,
		show_col,
		width,
		container_height,
		img_height,
		click_handler,
		input_change_input_handler,
		click_handler_1,
		input_input_handler
	];
}

class SketchSettings extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			brush_radius: 0,
			brush_color: 1,
			container_height: 7,
			img_width: 2,
			img_height: 8,
			mode: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SketchSettings",
			options,
			id: create_fragment$2.name
		});
	}

	get brush_radius() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_radius(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brush_color() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_color(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get container_height() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set container_height(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get img_width() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set img_width(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get img_height() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set img_height(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<SketchSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<SketchSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const Image_svelte_svelte_type_style_lang = '';

/* Users/peterallen/Projects/gradio/js/image/interactive/Image.svelte generated by Svelte v4.0.0 */
const file = "Users/peterallen/Projects/gradio/js/image/interactive/Image.svelte";

// (372:1) {:else}
function create_else_block_1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*value_*/ ctx[17].image || /*value_*/ ctx[17].data)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "loading", "lazy");
			attr_dev(img, "class", "s-OMDc-8quS0Lo");
			toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			add_location(img, file, 422, 2, 9879);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*handle_click*/ ctx[33], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value_*/ 131072 && !src_url_equal(img.src, img_src_value = /*value_*/ ctx[17].image || /*value_*/ ctx[17].data)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}

			if (dirty[0] & /*selectable*/ 4096) {
				toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(372:1) {:else}",
		ctx
	});

	return block;
}

// (331:94) 
function create_if_block_13(ctx) {
	let previous_key = /*static_image*/ ctx[26];
	let t;
	let if_block_anchor;
	let current;
	let key_block = create_key_block_1(ctx);
	let if_block = /*img_width*/ ctx[20] > 0 && create_if_block_14(ctx);

	const block = {
		c: function create() {
			key_block.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			key_block.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*static_image*/ 67108864 && safe_not_equal(previous_key, previous_key = /*static_image*/ ctx[26])) {
				key_block.d(1);
				key_block = create_key_block_1(ctx);
				key_block.c();
				key_block.m(t.parentNode, t);
			} else {
				key_block.p(ctx, dirty);
			}

			if (/*img_width*/ ctx[20] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*img_width*/ 1048576) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_14(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(if_block_anchor);
			}

			key_block.d(detaching);
			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(331:94) ",
		ctx
	});

	return block;
}

// (312:29) 
function create_if_block_12(ctx) {
	let modifyupload;
	let t;
	let img;
	let img_src_value;
	let current;
	let mounted;
	let dispose;

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[14], editable: true },
			$$inline: true
		});

	modifyupload.$on("edit", /*edit_handler_1*/ ctx[56]);
	modifyupload.$on("clear", /*handle_clear*/ ctx[28]);

	const block = {
		c: function create() {
			create_component(modifyupload.$$.fragment);
			t = space();
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*value_*/ ctx[17])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "loading", "lazy");
			attr_dev(img, "class", "s-OMDc-8quS0Lo");
			toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			add_location(img, file, 368, 2, 8517);
		},
		m: function mount(target, anchor) {
			mount_component(modifyupload, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, img, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(img, "click", /*handle_click*/ ctx[33], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 16384) modifyupload_changes.i18n = /*i18n*/ ctx[14];
			modifyupload.$set(modifyupload_changes);

			if (!current || dirty[0] & /*value_*/ 131072 && !src_url_equal(img.src, img_src_value = /*value_*/ ctx[17])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*selectable*/ 4096) {
				toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			}

			if (!current || dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modifyupload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modifyupload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(img);
			}

			destroy_component(modifyupload, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(312:29) ",
		ctx
	});

	return block;
}

// (306:29) 
function create_if_block_11(ctx) {
	let cropper_1;
	let t;
	let modifyupload;
	let current;
	let cropper_1_props = { image: /*value*/ ctx[0].data };
	cropper_1 = new Cropper_1({ props: cropper_1_props, $$inline: true });
	/*cropper_1_binding_1*/ ctx[54](cropper_1);
	cropper_1.$on("crop", /*handle_save*/ ctx[29]);

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[14] },
			$$inline: true
		});

	modifyupload.$on("clear", /*clear_handler_1*/ ctx[55]);

	const block = {
		c: function create() {
			create_component(cropper_1.$$.fragment);
			t = space();
			create_component(modifyupload.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cropper_1, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(modifyupload, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cropper_1_changes = {};
			if (dirty[0] & /*value*/ 1) cropper_1_changes.image = /*value*/ ctx[0].data;
			cropper_1.$set(cropper_1_changes);
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 16384) modifyupload_changes.i18n = /*i18n*/ ctx[14];
			modifyupload.$set(modifyupload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cropper_1.$$.fragment, local);
			transition_in(modifyupload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cropper_1.$$.fragment, local);
			transition_out(modifyupload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}

			/*cropper_1_binding_1*/ ctx[54](null);
			destroy_component(cropper_1, detaching);
			destroy_component(modifyupload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(306:29) ",
		ctx
	});

	return block;
}

// (294:58) 
function create_if_block_9(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*source*/ ctx[6] === "webcam" && !/*static_image*/ ctx[26] && create_if_block_10(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*source*/ ctx[6] === "webcam" && !/*static_image*/ ctx[26]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*source, static_image*/ 67108928) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(294:58) ",
		ctx
	});

	return block;
}

// (267:31) 
function create_if_block_7(ctx) {
	let modifysketch;
	let t0;
	let t1;
	let sketch_1;
	let updating_brush_radius;
	let updating_brush_color;
	let current;
	modifysketch = new ModifySketch({ $$inline: true });
	modifysketch.$on("undo", /*undo_handler_1*/ ctx[46]);
	modifysketch.$on("remove_image", /*handle_sketch_clear*/ ctx[31]);
	let if_block = /*tool*/ ctx[1] === "color-sketch" && create_if_block_8(ctx);

	function sketch_1_brush_radius_binding_1(value) {
		/*sketch_1_brush_radius_binding_1*/ ctx[49](value);
	}

	function sketch_1_brush_color_binding_1(value) {
		/*sketch_1_brush_color_binding_1*/ ctx[50](value);
	}

	let sketch_1_props = {
		value: /*value*/ ctx[0],
		mode: /*mode*/ ctx[22],
		width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24],
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		shape: /*shape*/ ctx[7]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketch_1_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketch_1_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketch_1 = new Sketch({ props: sketch_1_props, $$inline: true });
	binding_callbacks.push(() => bind(sketch_1, 'brush_radius', sketch_1_brush_radius_binding_1));
	binding_callbacks.push(() => bind(sketch_1, 'brush_color', sketch_1_brush_color_binding_1));
	/*sketch_1_binding_1*/ ctx[51](sketch_1);
	sketch_1.$on("change", /*handle_save*/ ctx[29]);
	sketch_1.$on("clear", /*handle_sketch_clear*/ ctx[31]);

	const block = {
		c: function create() {
			create_component(modifysketch.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(sketch_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(modifysketch, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(sketch_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*tool*/ ctx[1] === "color-sketch") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*tool*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const sketch_1_changes = {};
			if (dirty[0] & /*value*/ 1) sketch_1_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*mode*/ 4194304) sketch_1_changes.mode = /*mode*/ ctx[22];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketch_1_changes.width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketch_1_changes.height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketch_1_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*shape*/ 128) sketch_1_changes.shape = /*shape*/ ctx[7];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketch_1_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketch_1_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketch_1.$set(sketch_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modifysketch.$$.fragment, local);
			transition_in(if_block);
			transition_in(sketch_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modifysketch.$$.fragment, local);
			transition_out(if_block);
			transition_out(sketch_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
			}

			destroy_component(modifysketch, detaching);
			if (if_block) if_block.d(detaching);
			/*sketch_1_binding_1*/ ctx[51](null);
			destroy_component(sketch_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(267:31) ",
		ctx
	});

	return block;
}

// (167:1) {#if source === "upload"}
function create_if_block(ctx) {
	let upload;
	let updating_dragging;
	let current;

	function upload_dragging_binding(value) {
		/*upload_dragging_binding*/ ctx[45](value);
	}

	let upload_props = {
		filetype: "image/*",
		include_file_metadata: false,
		disable_click: !!/*value*/ ctx[0],
		root: /*root*/ ctx[13],
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*dragging*/ ctx[16] !== void 0) {
		upload_props.dragging = /*dragging*/ ctx[16];
	}

	upload = new Upload({ props: upload_props, $$inline: true });
	binding_callbacks.push(() => bind(upload, 'dragging', upload_dragging_binding));
	upload.$on("load", /*handle_upload*/ ctx[27]);

	const block = {
		c: function create() {
			create_component(upload.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(upload, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const upload_changes = {};
			if (dirty[0] & /*value*/ 1) upload_changes.disable_click = !!/*value*/ ctx[0];
			if (dirty[0] & /*root*/ 8192) upload_changes.root = /*root*/ ctx[13];

			if (dirty[0] & /*value, static_image, streaming, i18n, tool, value_, cropper, source, mirror_webcam, selectable, container_height, max_height, img_width, max_width, img_height, mode, brush_radius, brush_color, value_img, sketch, mask_opacity, shape*/ 134143439 | dirty[2] & /*$$scope*/ 8) {
				upload_changes.$$scope = { dirty, ctx };
			}

			if (!updating_dragging && dirty[0] & /*dragging*/ 65536) {
				updating_dragging = true;
				upload_changes.dragging = /*dragging*/ ctx[16];
				add_flush_callback(() => updating_dragging = false);
			}

			upload.$set(upload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(upload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(upload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(upload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(167:1) {#if source === \\\"upload\\\"}",
		ctx
	});

	return block;
}

// (332:2) {#key static_image}
function create_key_block_1(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "absolute-img s-OMDc-8quS0Lo");
			if (!src_url_equal(img.src, img_src_value = /*static_image*/ ctx[26] || /*value_*/ ctx[17])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "loading", "lazy");
			toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			add_location(img, file, 378, 3, 8793);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			/*img_binding_1*/ ctx[57](img);

			if (!mounted) {
				dispose = listen_dev(img, "load", /*handle_image_load*/ ctx[30], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*static_image, value_*/ 67239936 && !src_url_equal(img.src, img_src_value = /*static_image*/ ctx[26] || /*value_*/ ctx[17])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			/*img_binding_1*/ ctx[57](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block_1.name,
		type: "key",
		source: "(332:2) {#key static_image}",
		ctx
	});

	return block;
}

// (343:2) {#if img_width > 0}
function create_if_block_14(ctx) {
	let sketch_1;
	let updating_brush_radius;
	let updating_brush_color;
	let t0;
	let modifysketch;
	let t1;
	let if_block_anchor;
	let current;

	function sketch_1_brush_radius_binding_2(value) {
		/*sketch_1_brush_radius_binding_2*/ ctx[59](value);
	}

	function sketch_1_brush_color_binding_2(value) {
		/*sketch_1_brush_color_binding_2*/ ctx[60](value);
	}

	let sketch_1_props = {
		value: /*value*/ ctx[0],
		mode: /*mode*/ ctx[22],
		width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24],
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		value_img: /*value_img*/ ctx[23],
		source: /*source*/ ctx[6]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketch_1_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketch_1_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketch_1 = new Sketch({ props: sketch_1_props, $$inline: true });
	/*sketch_1_binding_2*/ ctx[58](sketch_1);
	binding_callbacks.push(() => bind(sketch_1, 'brush_radius', sketch_1_brush_radius_binding_2));
	binding_callbacks.push(() => bind(sketch_1, 'brush_color', sketch_1_brush_color_binding_2));
	sketch_1.$on("change", /*handle_save*/ ctx[29]);
	modifysketch = new ModifySketch({ $$inline: true });
	modifysketch.$on("undo", /*undo_handler_2*/ ctx[61]);
	modifysketch.$on("remove_image", /*handle_sketch_clear*/ ctx[31]);
	let if_block = (/*tool*/ ctx[1] === "color-sketch" || /*tool*/ ctx[1] === "sketch") && create_if_block_15(ctx);

	const block = {
		c: function create() {
			create_component(sketch_1.$$.fragment);
			t0 = space();
			create_component(modifysketch.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(sketch_1, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(modifysketch, target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sketch_1_changes = {};
			if (dirty[0] & /*value*/ 1) sketch_1_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*mode*/ 4194304) sketch_1_changes.mode = /*mode*/ ctx[22];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketch_1_changes.width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketch_1_changes.height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketch_1_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*value_img*/ 8388608) sketch_1_changes.value_img = /*value_img*/ ctx[23];
			if (dirty[0] & /*source*/ 64) sketch_1_changes.source = /*source*/ ctx[6];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketch_1_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketch_1_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketch_1.$set(sketch_1_changes);

			if (/*tool*/ ctx[1] === "color-sketch" || /*tool*/ ctx[1] === "sketch") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*tool*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_15(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sketch_1.$$.fragment, local);
			transition_in(modifysketch.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(sketch_1.$$.fragment, local);
			transition_out(modifysketch.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(if_block_anchor);
			}

			/*sketch_1_binding_2*/ ctx[58](null);
			destroy_component(sketch_1, detaching);
			destroy_component(modifysketch, detaching);
			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(343:2) {#if img_width > 0}",
		ctx
	});

	return block;
}

// (361:3) {#if tool === "color-sketch" || tool === "sketch"}
function create_if_block_15(ctx) {
	let sketchsettings;
	let updating_brush_radius;
	let updating_brush_color;
	let current;

	function sketchsettings_brush_radius_binding_2(value) {
		/*sketchsettings_brush_radius_binding_2*/ ctx[62](value);
	}

	function sketchsettings_brush_color_binding_2(value) {
		/*sketchsettings_brush_color_binding_2*/ ctx[63](value);
	}

	let sketchsettings_props = {
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		img_width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		img_height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24],
		mode: /*mode*/ ctx[22]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketchsettings_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketchsettings_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketchsettings = new SketchSettings({
			props: sketchsettings_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(sketchsettings, 'brush_radius', sketchsettings_brush_radius_binding_2));
	binding_callbacks.push(() => bind(sketchsettings, 'brush_color', sketchsettings_brush_color_binding_2));

	const block = {
		c: function create() {
			create_component(sketchsettings.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(sketchsettings, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sketchsettings_changes = {};
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketchsettings_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketchsettings_changes.img_width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketchsettings_changes.img_height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];
			if (dirty[0] & /*mode*/ 4194304) sketchsettings_changes.mode = /*mode*/ ctx[22];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketchsettings_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketchsettings_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketchsettings.$set(sketchsettings_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sketchsettings.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sketchsettings.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sketchsettings, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(361:3) {#if tool === \\\"color-sketch\\\" || tool === \\\"sketch\\\"}",
		ctx
	});

	return block;
}

// (295:2) {#if source === "webcam" && !static_image}
function create_if_block_10(ctx) {
	let webcam;
	let current;

	webcam = new Webcam$1({
			props: {
				streaming: /*streaming*/ ctx[8],
				pending: /*pending*/ ctx[9],
				mirror_webcam: /*mirror_webcam*/ ctx[10]
			},
			$$inline: true
		});

	webcam.$on("capture", /*capture_handler*/ ctx[52]);
	webcam.$on("stream", /*handle_save*/ ctx[29]);
	webcam.$on("error", /*error_handler*/ ctx[53]);

	const block = {
		c: function create() {
			create_component(webcam.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(webcam, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const webcam_changes = {};
			if (dirty[0] & /*streaming*/ 256) webcam_changes.streaming = /*streaming*/ ctx[8];
			if (dirty[0] & /*pending*/ 512) webcam_changes.pending = /*pending*/ ctx[9];
			if (dirty[0] & /*mirror_webcam*/ 1024) webcam_changes.mirror_webcam = /*mirror_webcam*/ ctx[10];
			webcam.$set(webcam_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(webcam.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(webcam.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(webcam, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(295:2) {#if source === \\\"webcam\\\" && !static_image}",
		ctx
	});

	return block;
}

// (272:2) {#if tool === "color-sketch"}
function create_if_block_8(ctx) {
	let sketchsettings;
	let updating_brush_radius;
	let updating_brush_color;
	let current;

	function sketchsettings_brush_radius_binding_1(value) {
		/*sketchsettings_brush_radius_binding_1*/ ctx[47](value);
	}

	function sketchsettings_brush_color_binding_1(value) {
		/*sketchsettings_brush_color_binding_1*/ ctx[48](value);
	}

	let sketchsettings_props = {
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		img_width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		img_height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketchsettings_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketchsettings_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketchsettings = new SketchSettings({
			props: sketchsettings_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(sketchsettings, 'brush_radius', sketchsettings_brush_radius_binding_1));
	binding_callbacks.push(() => bind(sketchsettings, 'brush_color', sketchsettings_brush_color_binding_1));

	const block = {
		c: function create() {
			create_component(sketchsettings.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(sketchsettings, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sketchsettings_changes = {};
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketchsettings_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketchsettings_changes.img_width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketchsettings_changes.img_height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketchsettings_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketchsettings_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketchsettings.$set(sketchsettings_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sketchsettings.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sketchsettings.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sketchsettings, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(272:2) {#if tool === \\\"color-sketch\\\"}",
		ctx
	});

	return block;
}

// (253:3) {:else}
function create_else_block(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*value*/ ctx[0].image || /*value*/ ctx[0].data)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "hello");
			attr_dev(img, "loading", "lazy");
			attr_dev(img, "class", "s-OMDc-8quS0Lo");
			toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			add_location(img, file, 302, 4, 6840);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*handle_click*/ ctx[33], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && !src_url_equal(img.src, img_src_value = /*value*/ ctx[0].image || /*value*/ ctx[0].data)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}

			if (dirty[0] & /*selectable*/ 4096) {
				toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(253:3) {:else}",
		ctx
	});

	return block;
}

// (207:96) 
function create_if_block_4(ctx) {
	let previous_key = /*static_image*/ ctx[26];
	let t;
	let if_block_anchor;
	let current;
	let key_block = create_key_block(ctx);
	let if_block = /*img_width*/ ctx[20] > 0 && create_if_block_5(ctx);

	const block = {
		c: function create() {
			key_block.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			key_block.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*static_image*/ 67108864 && safe_not_equal(previous_key, previous_key = /*static_image*/ ctx[26])) {
				key_block.d(1);
				key_block = create_key_block(ctx);
				key_block.c();
				key_block.m(t.parentNode, t);
			} else {
				key_block.p(ctx, dirty);
			}

			if (/*img_width*/ ctx[20] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*img_width*/ 1048576) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(if_block_anchor);
			}

			key_block.d(detaching);
			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(207:96) ",
		ctx
	});

	return block;
}

// (188:31) 
function create_if_block_3(ctx) {
	let modifyupload;
	let t;
	let img;
	let img_src_value;
	let current;
	let mounted;
	let dispose;

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[14], editable: true },
			$$inline: true
		});

	modifyupload.$on("edit", /*edit_handler*/ ctx[37]);
	modifyupload.$on("clear", /*handle_clear*/ ctx[28]);

	const block = {
		c: function create() {
			create_component(modifyupload.$$.fragment);
			t = space();
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*value_*/ ctx[17].data)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "loading", "lazy");
			attr_dev(img, "class", "s-OMDc-8quS0Lo");
			toggle_class(img, "scale-x-[-1]", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			add_location(img, file, 244, 4, 5201);
		},
		m: function mount(target, anchor) {
			mount_component(modifyupload, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, img, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(img, "click", /*handle_click*/ ctx[33], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 16384) modifyupload_changes.i18n = /*i18n*/ ctx[14];
			modifyupload.$set(modifyupload_changes);

			if (!current || dirty[0] & /*value_*/ 131072 && !src_url_equal(img.src, img_src_value = /*value_*/ ctx[17].data)) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "scale-x-[-1]", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}

			if (!current || dirty[0] & /*selectable*/ 4096) {
				toggle_class(img, "selectable", /*selectable*/ ctx[12]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modifyupload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modifyupload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(img);
			}

			destroy_component(modifyupload, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(188:31) ",
		ctx
	});

	return block;
}

// (178:31) 
function create_if_block_2(ctx) {
	let cropper_1;
	let t;
	let modifyupload;
	let current;
	let cropper_1_props = { image: /*value_*/ ctx[17].data };
	cropper_1 = new Cropper_1({ props: cropper_1_props, $$inline: true });
	/*cropper_1_binding*/ ctx[35](cropper_1);
	cropper_1.$on("crop", /*handle_save*/ ctx[29]);

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[14] },
			$$inline: true
		});

	modifyupload.$on("clear", /*clear_handler*/ ctx[36]);

	const block = {
		c: function create() {
			create_component(cropper_1.$$.fragment);
			t = space();
			create_component(modifyupload.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cropper_1, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(modifyupload, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cropper_1_changes = {};
			if (dirty[0] & /*value_*/ 131072) cropper_1_changes.image = /*value_*/ ctx[17].data;
			cropper_1.$set(cropper_1_changes);
			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 16384) modifyupload_changes.i18n = /*i18n*/ ctx[14];
			modifyupload.$set(modifyupload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cropper_1.$$.fragment, local);
			transition_in(modifyupload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cropper_1.$$.fragment, local);
			transition_out(modifyupload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}

			/*cropper_1_binding*/ ctx[35](null);
			destroy_component(cropper_1, detaching);
			destroy_component(modifyupload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(178:31) ",
		ctx
	});

	return block;
}

// (176:3) {#if (value === null && !static_image) || streaming}
function create_if_block_1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[34].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[65], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[65],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[65])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[65], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(176:3) {#if (value === null && !static_image) || streaming}",
		ctx
	});

	return block;
}

// (208:4) {#key static_image}
function create_key_block(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "absolute-img s-OMDc-8quS0Lo");
			if (!src_url_equal(img.src, img_src_value = /*static_image*/ ctx[26] || /*value*/ ctx[0]?.image?.data || /*value*/ ctx[0]?.data)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "loading", "lazy");
			attr_dev(img, "crossorigin", "anonymous");
			toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			add_location(img, file, 254, 5, 5508);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
			/*img_binding*/ ctx[38](img);

			if (!mounted) {
				dispose = listen_dev(img, "load", /*handle_image_load*/ ctx[30], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*static_image, value*/ 67108865 && !src_url_equal(img.src, img_src_value = /*static_image*/ ctx[26] || /*value*/ ctx[0]?.image?.data || /*value*/ ctx[0]?.data)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty[0] & /*source, mirror_webcam*/ 1088) {
				toggle_class(img, "webcam", /*source*/ ctx[6] === "webcam" && /*mirror_webcam*/ ctx[10]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			/*img_binding*/ ctx[38](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block.name,
		type: "key",
		source: "(208:4) {#key static_image}",
		ctx
	});

	return block;
}

// (220:4) {#if img_width > 0}
function create_if_block_5(ctx) {
	let sketch_1;
	let updating_brush_radius;
	let updating_brush_color;
	let t0;
	let modifysketch;
	let t1;
	let if_block_anchor;
	let current;

	function sketch_1_brush_radius_binding(value) {
		/*sketch_1_brush_radius_binding*/ ctx[40](value);
	}

	function sketch_1_brush_color_binding(value) {
		/*sketch_1_brush_color_binding*/ ctx[41](value);
	}

	let sketch_1_props = {
		value: /*value*/ ctx[0],
		mask_opacity: /*mask_opacity*/ ctx[11],
		mode: /*mode*/ ctx[22],
		width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24],
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		value_img: /*value_img*/ ctx[23],
		source: /*source*/ ctx[6],
		shape: /*shape*/ ctx[7]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketch_1_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketch_1_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketch_1 = new Sketch({ props: sketch_1_props, $$inline: true });
	/*sketch_1_binding*/ ctx[39](sketch_1);
	binding_callbacks.push(() => bind(sketch_1, 'brush_radius', sketch_1_brush_radius_binding));
	binding_callbacks.push(() => bind(sketch_1, 'brush_color', sketch_1_brush_color_binding));
	sketch_1.$on("change", /*handle_save*/ ctx[29]);

	modifysketch = new ModifySketch({
			props: { show_eraser: /*value_img*/ ctx[23] },
			$$inline: true
		});

	modifysketch.$on("undo", /*undo_handler*/ ctx[42]);
	modifysketch.$on("clear_mask", /*handle_mask_clear*/ ctx[32]);
	modifysketch.$on("remove_image", /*handle_sketch_clear*/ ctx[31]);
	let if_block = (/*tool*/ ctx[1] === "color-sketch" || /*tool*/ ctx[1] === "sketch") && create_if_block_6(ctx);

	const block = {
		c: function create() {
			create_component(sketch_1.$$.fragment);
			t0 = space();
			create_component(modifysketch.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(sketch_1, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(modifysketch, target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sketch_1_changes = {};
			if (dirty[0] & /*value*/ 1) sketch_1_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*mask_opacity*/ 2048) sketch_1_changes.mask_opacity = /*mask_opacity*/ ctx[11];
			if (dirty[0] & /*mode*/ 4194304) sketch_1_changes.mode = /*mode*/ ctx[22];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketch_1_changes.width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketch_1_changes.height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketch_1_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*value_img*/ 8388608) sketch_1_changes.value_img = /*value_img*/ ctx[23];
			if (dirty[0] & /*source*/ 64) sketch_1_changes.source = /*source*/ ctx[6];
			if (dirty[0] & /*shape*/ 128) sketch_1_changes.shape = /*shape*/ ctx[7];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketch_1_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketch_1_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketch_1.$set(sketch_1_changes);
			const modifysketch_changes = {};
			if (dirty[0] & /*value_img*/ 8388608) modifysketch_changes.show_eraser = /*value_img*/ ctx[23];
			modifysketch.$set(modifysketch_changes);

			if (/*tool*/ ctx[1] === "color-sketch" || /*tool*/ ctx[1] === "sketch") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*tool*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sketch_1.$$.fragment, local);
			transition_in(modifysketch.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(sketch_1.$$.fragment, local);
			transition_out(modifysketch.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(if_block_anchor);
			}

			/*sketch_1_binding*/ ctx[39](null);
			destroy_component(sketch_1, detaching);
			destroy_component(modifysketch, detaching);
			if (if_block) if_block.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(220:4) {#if img_width > 0}",
		ctx
	});

	return block;
}

// (242:5) {#if tool === "color-sketch" || tool === "sketch"}
function create_if_block_6(ctx) {
	let sketchsettings;
	let updating_brush_radius;
	let updating_brush_color;
	let current;

	function sketchsettings_brush_radius_binding(value) {
		/*sketchsettings_brush_radius_binding*/ ctx[43](value);
	}

	function sketchsettings_brush_color_binding(value) {
		/*sketchsettings_brush_color_binding*/ ctx[44](value);
	}

	let sketchsettings_props = {
		container_height: /*container_height*/ ctx[21] || /*max_height*/ ctx[24],
		img_width: /*img_width*/ ctx[20] || /*max_width*/ ctx[25],
		img_height: /*img_height*/ ctx[19] || /*max_height*/ ctx[24],
		mode: /*mode*/ ctx[22]
	};

	if (/*brush_radius*/ ctx[2] !== void 0) {
		sketchsettings_props.brush_radius = /*brush_radius*/ ctx[2];
	}

	if (/*brush_color*/ ctx[3] !== void 0) {
		sketchsettings_props.brush_color = /*brush_color*/ ctx[3];
	}

	sketchsettings = new SketchSettings({
			props: sketchsettings_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(sketchsettings, 'brush_radius', sketchsettings_brush_radius_binding));
	binding_callbacks.push(() => bind(sketchsettings, 'brush_color', sketchsettings_brush_color_binding));

	const block = {
		c: function create() {
			create_component(sketchsettings.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(sketchsettings, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sketchsettings_changes = {};
			if (dirty[0] & /*container_height, max_height*/ 18874368) sketchsettings_changes.container_height = /*container_height*/ ctx[21] || /*max_height*/ ctx[24];
			if (dirty[0] & /*img_width, max_width*/ 34603008) sketchsettings_changes.img_width = /*img_width*/ ctx[20] || /*max_width*/ ctx[25];
			if (dirty[0] & /*img_height, max_height*/ 17301504) sketchsettings_changes.img_height = /*img_height*/ ctx[19] || /*max_height*/ ctx[24];
			if (dirty[0] & /*mode*/ 4194304) sketchsettings_changes.mode = /*mode*/ ctx[22];

			if (!updating_brush_radius && dirty[0] & /*brush_radius*/ 4) {
				updating_brush_radius = true;
				sketchsettings_changes.brush_radius = /*brush_radius*/ ctx[2];
				add_flush_callback(() => updating_brush_radius = false);
			}

			if (!updating_brush_color && dirty[0] & /*brush_color*/ 8) {
				updating_brush_color = true;
				sketchsettings_changes.brush_color = /*brush_color*/ ctx[3];
				add_flush_callback(() => updating_brush_color = false);
			}

			sketchsettings.$set(sketchsettings_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sketchsettings.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sketchsettings.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(sketchsettings, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(242:5) {#if tool === \\\"color-sketch\\\" || tool === \\\"sketch\\\"}",
		ctx
	});

	return block;
}

// (168:2) <Upload    bind:dragging    filetype="image/*"    on:load={handle_upload}    include_file_metadata={false}    disable_click={!!value}    {root}   >
function create_default_slot$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_1,
		create_if_block_2,
		create_if_block_3,
		create_if_block_4,
		create_else_block
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*value*/ ctx[0] === null && !/*static_image*/ ctx[26] || /*streaming*/ ctx[8]) return 0;
		if (/*tool*/ ctx[1] === "select") return 1;
		if (/*tool*/ ctx[1] === "editor") return 2;
		if ((/*tool*/ ctx[1] === "sketch" || /*tool*/ ctx[1] === "color-sketch") && (/*value*/ ctx[0] !== null || /*static_image*/ ctx[26])) return 3;
		return 4;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(168:2) <Upload    bind:dragging    filetype=\\\"image/*\\\"    on:load={handle_upload}    include_file_metadata={false}    disable_click={!!value}    {root}   >",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let blocklabel;
	let t;
	let div;
	let current_block_type_index;
	let if_block;
	let div_resize_listener;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[5],
				Icon: /*source*/ ctx[6] === "canvas" ? Sketch$1 : Image,
				label: /*label*/ ctx[4] || (/*source*/ ctx[6] === "canvas" ? "Sketch" : "Image")
			},
			$$inline: true
		});

	const if_block_creators = [
		create_if_block,
		create_if_block_7,
		create_if_block_9,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_else_block_1
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*source*/ ctx[6] === "upload") return 0;
		if (/*source*/ ctx[6] === "canvas") return 1;
		if (/*value*/ ctx[0] === null && !/*static_image*/ ctx[26] || /*streaming*/ ctx[8]) return 2;
		if (/*tool*/ ctx[1] === "select") return 3;
		if (/*tool*/ ctx[1] === "editor") return 4;
		if ((/*tool*/ ctx[1] === "sketch" || /*tool*/ ctx[1] === "color-sketch") && (/*value*/ ctx[0] !== null || /*static_image*/ ctx[26])) return 5;
		return 6;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(blocklabel.$$.fragment);
			t = space();
			div = element("div");
			if_block.c();
			attr_dev(div, "data-testid", "image");
			attr_dev(div, "class", "image-container s-OMDc-8quS0Lo");
			add_render_callback(() => /*div_elementresize_handler*/ ctx[64].call(div));
			add_location(div, file, 206, 0, 4305);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(blocklabel, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			div_resize_listener = add_iframe_resize_listener(div, /*div_elementresize_handler*/ ctx[64].bind(div));
			current = true;
		},
		p: function update(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 32) blocklabel_changes.show_label = /*show_label*/ ctx[5];
			if (dirty[0] & /*source*/ 64) blocklabel_changes.Icon = /*source*/ ctx[6] === "canvas" ? Sketch$1 : Image;
			if (dirty[0] & /*label, source*/ 80) blocklabel_changes.label = /*label*/ ctx[4] || (/*source*/ ctx[6] === "canvas" ? "Sketch" : "Image");
			blocklabel.$set(blocklabel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(blocklabel.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(blocklabel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(div);
			}

			destroy_component(blocklabel, detaching);
			if_blocks[current_block_type_index].d();
			div_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Image', slots, ['default']);
	let { value } = $$props;
	let { label = undefined } = $$props;
	let { show_label } = $$props;
	let { source = "upload" } = $$props;
	let { tool = "editor" } = $$props;
	let { shape } = $$props;
	let { streaming = false } = $$props;
	let { pending = false } = $$props;
	let { mirror_webcam } = $$props;
	let { brush_radius } = $$props;
	let { brush_color = "#000000" } = $$props;
	let { mask_opacity } = $$props;
	let { selectable = false } = $$props;
	let { root } = $$props;
	let { i18n } = $$props;
	let sketch;
	let cropper;

	if (value && (source === "upload" || source === "webcam") && tool === "sketch") {
		value = { image: value, mask: null };
	}

	function handle_upload({ detail }) {
		if (tool === "color-sketch") {
			$$invalidate(26, static_image = normalise_file(detail, root, null)?.data);
		} else {
			$$invalidate(0, value = (source === "upload" || source === "webcam") && tool === "sketch"
			? {
					image: normalise_file(detail, root, null),
					mask: null
				}
			: normalise_file(detail, root, null));
		}

		dispatch("upload", normalise_file(detail, root, null));
	}

	function handle_clear({ detail }) {
		$$invalidate(0, value = null);
		$$invalidate(26, static_image = undefined);
		dispatch("clear");
	}

	async function handle_save({ detail }, initial) {
		if (mode === "mask") {
			if (source === "webcam" && initial) {
				$$invalidate(0, value = { image: detail, mask: null });
			} else {
				$$invalidate(0, value = {
					image: typeof value === "string" ? value : value?.image || null,
					mask: detail
				});
			}
		} else if ((source === "upload" || source === "webcam") && tool === "sketch") {
			$$invalidate(0, value = { image: detail, mask: null });
		} else {
			$$invalidate(0, value = detail);
		}

		await tick();
		dispatch(streaming ? "stream" : "edit");
	}

	const dispatch = createEventDispatcher();
	let dragging = false;
	let value_ = null;

	function handle_image_load(event) {
		const element = event.currentTarget;
		$$invalidate(20, img_width = element.naturalWidth);
		$$invalidate(19, img_height = element.naturalHeight);
		$$invalidate(21, container_height = element.getBoundingClientRect().height);
	}

	async function handle_sketch_clear() {
		dispatch("clear");
		sketch.clear();
		await tick();
		$$invalidate(0, value = null);
		$$invalidate(26, static_image = undefined);
	}

	async function handle_mask_clear() {
		sketch.clear_mask();
		await tick();
	}

	let img_height = 0;
	let img_width = 0;
	let container_height = 0;
	let mode;
	let value_img;
	let max_height;
	let max_width;
	let static_image = undefined;

	onMount(async () => {
		if (tool === "color-sketch" && value && typeof value === "string") {
			$$invalidate(26, static_image = value);
			await tick();
			handle_image_load({ currentTarget: value_img });
		}
	});

	function handle_click(evt) {
		let coordinates = get_coordinates_of_clicked_image(evt);

		if (coordinates) {
			dispatch("select", { index: coordinates, value: null });
		}
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<Image> was created without expected prop 'value'");
		}

		if (show_label === undefined && !('show_label' in $$props || $$self.$$.bound[$$self.$$.props['show_label']])) {
			console.warn("<Image> was created without expected prop 'show_label'");
		}

		if (shape === undefined && !('shape' in $$props || $$self.$$.bound[$$self.$$.props['shape']])) {
			console.warn("<Image> was created without expected prop 'shape'");
		}

		if (mirror_webcam === undefined && !('mirror_webcam' in $$props || $$self.$$.bound[$$self.$$.props['mirror_webcam']])) {
			console.warn("<Image> was created without expected prop 'mirror_webcam'");
		}

		if (brush_radius === undefined && !('brush_radius' in $$props || $$self.$$.bound[$$self.$$.props['brush_radius']])) {
			console.warn("<Image> was created without expected prop 'brush_radius'");
		}

		if (mask_opacity === undefined && !('mask_opacity' in $$props || $$self.$$.bound[$$self.$$.props['mask_opacity']])) {
			console.warn("<Image> was created without expected prop 'mask_opacity'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<Image> was created without expected prop 'root'");
		}

		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<Image> was created without expected prop 'i18n'");
		}
	});

	const writable_props = [
		'value',
		'label',
		'show_label',
		'source',
		'tool',
		'shape',
		'streaming',
		'pending',
		'mirror_webcam',
		'brush_radius',
		'brush_color',
		'mask_opacity',
		'selectable',
		'root',
		'i18n'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Image> was created with unknown prop '${key}'`);
	});

	function cropper_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			cropper = $$value;
			($$invalidate(15, cropper), $$invalidate(0, value));
		});
	}

	const clear_handler = e => (handle_clear(e), $$invalidate(1, tool = "editor"));
	const edit_handler = () => $$invalidate(1, tool = "select");

	function img_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			value_img = $$value;
			$$invalidate(23, value_img);
		});
	}

	function sketch_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sketch = $$value;
			$$invalidate(18, sketch);
		});
	}

	function sketch_1_brush_radius_binding(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketch_1_brush_color_binding(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	const undo_handler = () => sketch.undo();

	function sketchsettings_brush_radius_binding(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketchsettings_brush_color_binding(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	function upload_dragging_binding(value) {
		dragging = value;
		$$invalidate(16, dragging);
	}

	const undo_handler_1 = () => sketch.undo();

	function sketchsettings_brush_radius_binding_1(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketchsettings_brush_color_binding_1(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	function sketch_1_brush_radius_binding_1(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketch_1_brush_color_binding_1(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	function sketch_1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sketch = $$value;
			$$invalidate(18, sketch);
		});
	}

	const capture_handler = e => tool === "color-sketch"
	? handle_upload(e)
	: handle_save(e, true);

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	function cropper_1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			cropper = $$value;
			($$invalidate(15, cropper), $$invalidate(0, value));
		});
	}

	const clear_handler_1 = e => (handle_clear(e), $$invalidate(1, tool = "editor"));
	const edit_handler_1 = () => $$invalidate(1, tool = "select");

	function img_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			value_img = $$value;
			$$invalidate(23, value_img);
		});
	}

	function sketch_1_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sketch = $$value;
			$$invalidate(18, sketch);
		});
	}

	function sketch_1_brush_radius_binding_2(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketch_1_brush_color_binding_2(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	const undo_handler_2 = () => sketch.undo();

	function sketchsettings_brush_radius_binding_2(value) {
		brush_radius = value;
		$$invalidate(2, brush_radius);
	}

	function sketchsettings_brush_color_binding_2(value) {
		brush_color = value;
		$$invalidate(3, brush_color);
	}

	function div_elementresize_handler() {
		max_height = this.offsetHeight;
		max_width = this.offsetWidth;
		$$invalidate(24, max_height);
		$$invalidate(25, max_width);
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(5, show_label = $$props.show_label);
		if ('source' in $$props) $$invalidate(6, source = $$props.source);
		if ('tool' in $$props) $$invalidate(1, tool = $$props.tool);
		if ('shape' in $$props) $$invalidate(7, shape = $$props.shape);
		if ('streaming' in $$props) $$invalidate(8, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(9, pending = $$props.pending);
		if ('mirror_webcam' in $$props) $$invalidate(10, mirror_webcam = $$props.mirror_webcam);
		if ('brush_radius' in $$props) $$invalidate(2, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(3, brush_color = $$props.brush_color);
		if ('mask_opacity' in $$props) $$invalidate(11, mask_opacity = $$props.mask_opacity);
		if ('selectable' in $$props) $$invalidate(12, selectable = $$props.selectable);
		if ('root' in $$props) $$invalidate(13, root = $$props.root);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('$$scope' in $$props) $$invalidate(65, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		tick,
		onMount,
		BlockLabel,
		Image,
		SketchIcon: Sketch$1,
		get_coordinates_of_clicked_image,
		Cropper: Cropper_1,
		Sketch,
		Webcam: Webcam$1,
		ModifySketch,
		SketchSettings,
		Upload,
		ModifyUpload,
		normalise_file,
		value,
		label,
		show_label,
		source,
		tool,
		shape,
		streaming,
		pending,
		mirror_webcam,
		brush_radius,
		brush_color,
		mask_opacity,
		selectable,
		root,
		i18n,
		sketch,
		cropper,
		handle_upload,
		handle_clear,
		handle_save,
		dispatch,
		dragging,
		value_,
		handle_image_load,
		handle_sketch_clear,
		handle_mask_clear,
		img_height,
		img_width,
		container_height,
		mode,
		value_img,
		max_height,
		max_width,
		static_image,
		handle_click
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(5, show_label = $$props.show_label);
		if ('source' in $$props) $$invalidate(6, source = $$props.source);
		if ('tool' in $$props) $$invalidate(1, tool = $$props.tool);
		if ('shape' in $$props) $$invalidate(7, shape = $$props.shape);
		if ('streaming' in $$props) $$invalidate(8, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(9, pending = $$props.pending);
		if ('mirror_webcam' in $$props) $$invalidate(10, mirror_webcam = $$props.mirror_webcam);
		if ('brush_radius' in $$props) $$invalidate(2, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(3, brush_color = $$props.brush_color);
		if ('mask_opacity' in $$props) $$invalidate(11, mask_opacity = $$props.mask_opacity);
		if ('selectable' in $$props) $$invalidate(12, selectable = $$props.selectable);
		if ('root' in $$props) $$invalidate(13, root = $$props.root);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
		if ('sketch' in $$props) $$invalidate(18, sketch = $$props.sketch);
		if ('cropper' in $$props) $$invalidate(15, cropper = $$props.cropper);
		if ('dragging' in $$props) $$invalidate(16, dragging = $$props.dragging);
		if ('value_' in $$props) $$invalidate(17, value_ = $$props.value_);
		if ('img_height' in $$props) $$invalidate(19, img_height = $$props.img_height);
		if ('img_width' in $$props) $$invalidate(20, img_width = $$props.img_width);
		if ('container_height' in $$props) $$invalidate(21, container_height = $$props.container_height);
		if ('mode' in $$props) $$invalidate(22, mode = $$props.mode);
		if ('value_img' in $$props) $$invalidate(23, value_img = $$props.value_img);
		if ('max_height' in $$props) $$invalidate(24, max_height = $$props.max_height);
		if ('max_width' in $$props) $$invalidate(25, max_width = $$props.max_width);
		if ('static_image' in $$props) $$invalidate(26, static_image = $$props.static_image);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*dragging*/ 65536) {
			dispatch("drag", dragging);
		}

		if ($$self.$$.dirty[0] & /*value, value_, root*/ 139265) {
			if (value !== value_) {
				$$invalidate(17, value_ = value);
				normalise_file(value_, root, null);
			}
		}

		if ($$self.$$.dirty[0] & /*source, tool*/ 66) {
			{
				if (source === "canvas" && tool === "sketch") {
					$$invalidate(22, mode = "bw-sketch");
				} else if (tool === "color-sketch") {
					$$invalidate(22, mode = "color-sketch");
				} else if ((source === "upload" || source === "webcam") && tool === "sketch") {
					$$invalidate(22, mode = "mask");
				} else {
					$$invalidate(22, mode = "editor");
				}
			}
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			{
				if (value === null || value.image === null && value.mask === null) {
					$$invalidate(26, static_image = undefined);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*cropper, value*/ 32769) {
			{
				if (cropper) {
					if (value) {
						$$invalidate(15, cropper.image = value, cropper);
						cropper.create();
					} else {
						cropper.destroy();
					}
				}
			}
		}
	};

	return [
		value,
		tool,
		brush_radius,
		brush_color,
		label,
		show_label,
		source,
		shape,
		streaming,
		pending,
		mirror_webcam,
		mask_opacity,
		selectable,
		root,
		i18n,
		cropper,
		dragging,
		value_,
		sketch,
		img_height,
		img_width,
		container_height,
		mode,
		value_img,
		max_height,
		max_width,
		static_image,
		handle_upload,
		handle_clear,
		handle_save,
		handle_image_load,
		handle_sketch_clear,
		handle_mask_clear,
		handle_click,
		slots,
		cropper_1_binding,
		clear_handler,
		edit_handler,
		img_binding,
		sketch_1_binding,
		sketch_1_brush_radius_binding,
		sketch_1_brush_color_binding,
		undo_handler,
		sketchsettings_brush_radius_binding,
		sketchsettings_brush_color_binding,
		upload_dragging_binding,
		undo_handler_1,
		sketchsettings_brush_radius_binding_1,
		sketchsettings_brush_color_binding_1,
		sketch_1_brush_radius_binding_1,
		sketch_1_brush_color_binding_1,
		sketch_1_binding_1,
		capture_handler,
		error_handler,
		cropper_1_binding_1,
		clear_handler_1,
		edit_handler_1,
		img_binding_1,
		sketch_1_binding_2,
		sketch_1_brush_radius_binding_2,
		sketch_1_brush_color_binding_2,
		undo_handler_2,
		sketchsettings_brush_radius_binding_2,
		sketchsettings_brush_color_binding_2,
		div_elementresize_handler,
		$$scope
	];
}

class Image_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				value: 0,
				label: 4,
				show_label: 5,
				source: 6,
				tool: 1,
				shape: 7,
				streaming: 8,
				pending: 9,
				mirror_webcam: 10,
				brush_radius: 2,
				brush_color: 3,
				mask_opacity: 11,
				selectable: 12,
				root: 13,
				i18n: 14
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Image_1",
			options,
			id: create_fragment$1.name
		});
	}

	get value() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_label() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_label(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get source() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set source(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tool() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tool(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shape() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shape(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get streaming() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set streaming(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pending() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pending(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mirror_webcam() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mirror_webcam(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brush_radius() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_radius(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get brush_color() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brush_color(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mask_opacity() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mask_opacity(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectable() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectable(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get root() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set root(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/peterallen/Projects/gradio/js/image/interactive/InteractiveImage.svelte generated by Svelte v4.0.0 */

// (57:1) <Image   {brush_radius}   {brush_color}   {shape}   bind:value   {source}   {tool}   {selectable}   {mask_opacity}   {root}   on:edit={() => gradio.dispatch("edit")}   on:clear={() => gradio.dispatch("clear")}   on:stream={() => gradio.dispatch("stream")}   on:drag={({ detail }) => (dragging = detail)}   on:upload={() => gradio.dispatch("upload")}   on:select={({ detail }) => gradio.dispatch("select", detail)}   on:share={({ detail }) => gradio.dispatch("share", detail)}   on:error={({ detail }) => {    loading_status = loading_status || {};    loading_status.status = "error";    gradio.dispatch("error", detail);   }}   {label}   {show_label}   {pending}   {streaming}   {mirror_webcam}   i18n={gradio.i18n}  >
function create_default_slot_1(ctx) {
	let uploadtext;
	let current;

	uploadtext = new UploadText({
			props: {
				i18n: /*gradio*/ ctx[23].i18n,
				type: "image"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(uploadtext.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(uploadtext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const uploadtext_changes = {};
			if (dirty[0] & /*gradio*/ 8388608) uploadtext_changes.i18n = /*gradio*/ ctx[23].i18n;
			uploadtext.$set(uploadtext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(uploadtext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(uploadtext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(uploadtext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(57:1) <Image   {brush_radius}   {brush_color}   {shape}   bind:value   {source}   {tool}   {selectable}   {mask_opacity}   {root}   on:edit={() => gradio.dispatch(\\\"edit\\\")}   on:clear={() => gradio.dispatch(\\\"clear\\\")}   on:stream={() => gradio.dispatch(\\\"stream\\\")}   on:drag={({ detail }) => (dragging = detail)}   on:upload={() => gradio.dispatch(\\\"upload\\\")}   on:select={({ detail }) => gradio.dispatch(\\\"select\\\", detail)}   on:share={({ detail }) => gradio.dispatch(\\\"share\\\", detail)}   on:error={({ detail }) => {    loading_status = loading_status || {};    loading_status.status = \\\"error\\\";    gradio.dispatch(\\\"error\\\", detail);   }}   {label}   {show_label}   {pending}   {streaming}   {mirror_webcam}   i18n={gradio.i18n}  >",
		ctx
	});

	return block;
}

// (37:0) <Block  {visible}  variant={value === null && source === "upload" ? "dashed" : "solid"}  border_mode={dragging ? "focus" : "base"}  padding={false}  {elem_id}  {elem_classes}  height={height || (source === "webcam" ? undefined : FIXED_HEIGHT)}  {width}  allow_overflow={false}  {container}  {scale}  {min_width} >
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let image;
	let updating_value;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[23].autoscroll
		},
		{ i18n: /*gradio*/ ctx[23].i18n },
		/*loading_status*/ ctx[1]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign$1(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({
			props: statustracker_props,
			$$inline: true
		});

	function image_value_binding(value) {
		/*image_value_binding*/ ctx[25](value);
	}

	let image_props = {
		brush_radius: /*brush_radius*/ ctx[15],
		brush_color: /*brush_color*/ ctx[16],
		shape: /*shape*/ ctx[14],
		source: /*source*/ ctx[5],
		tool: /*tool*/ ctx[6],
		selectable: /*selectable*/ ctx[18],
		mask_opacity: /*mask_opacity*/ ctx[17],
		root: /*root*/ ctx[22],
		label: /*label*/ ctx[7],
		show_label: /*show_label*/ ctx[8],
		pending: /*pending*/ ctx[10],
		streaming: /*streaming*/ ctx[9],
		mirror_webcam: /*mirror_webcam*/ ctx[13],
		i18n: /*gradio*/ ctx[23].i18n,
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*value*/ ctx[0] !== void 0) {
		image_props.value = /*value*/ ctx[0];
	}

	image = new Image_1({ props: image_props, $$inline: true });
	binding_callbacks.push(() => bind(image, 'value', image_value_binding));
	image.$on("edit", /*edit_handler*/ ctx[26]);
	image.$on("clear", /*clear_handler*/ ctx[27]);
	image.$on("stream", /*stream_handler*/ ctx[28]);
	image.$on("drag", /*drag_handler*/ ctx[29]);
	image.$on("upload", /*upload_handler*/ ctx[30]);
	image.$on("select", /*select_handler*/ ctx[31]);
	image.$on("share", /*share_handler*/ ctx[32]);
	image.$on("error", /*error_handler*/ ctx[33]);

	const block = {
		c: function create() {
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(image.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(image, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const statustracker_changes = (dirty[0] & /*gradio, loading_status*/ 8388610)
			? get_spread_update(statustracker_spread_levels, [
					dirty[0] & /*gradio*/ 8388608 && {
						autoscroll: /*gradio*/ ctx[23].autoscroll
					},
					dirty[0] & /*gradio*/ 8388608 && { i18n: /*gradio*/ ctx[23].i18n },
					dirty[0] & /*loading_status*/ 2 && get_spread_object(/*loading_status*/ ctx[1])
				])
			: {};

			statustracker.$set(statustracker_changes);
			const image_changes = {};
			if (dirty[0] & /*brush_radius*/ 32768) image_changes.brush_radius = /*brush_radius*/ ctx[15];
			if (dirty[0] & /*brush_color*/ 65536) image_changes.brush_color = /*brush_color*/ ctx[16];
			if (dirty[0] & /*shape*/ 16384) image_changes.shape = /*shape*/ ctx[14];
			if (dirty[0] & /*source*/ 32) image_changes.source = /*source*/ ctx[5];
			if (dirty[0] & /*tool*/ 64) image_changes.tool = /*tool*/ ctx[6];
			if (dirty[0] & /*selectable*/ 262144) image_changes.selectable = /*selectable*/ ctx[18];
			if (dirty[0] & /*mask_opacity*/ 131072) image_changes.mask_opacity = /*mask_opacity*/ ctx[17];
			if (dirty[0] & /*root*/ 4194304) image_changes.root = /*root*/ ctx[22];
			if (dirty[0] & /*label*/ 128) image_changes.label = /*label*/ ctx[7];
			if (dirty[0] & /*show_label*/ 256) image_changes.show_label = /*show_label*/ ctx[8];
			if (dirty[0] & /*pending*/ 1024) image_changes.pending = /*pending*/ ctx[10];
			if (dirty[0] & /*streaming*/ 512) image_changes.streaming = /*streaming*/ ctx[9];
			if (dirty[0] & /*mirror_webcam*/ 8192) image_changes.mirror_webcam = /*mirror_webcam*/ ctx[13];
			if (dirty[0] & /*gradio*/ 8388608) image_changes.i18n = /*gradio*/ ctx[23].i18n;

			if (dirty[0] & /*gradio*/ 8388608 | dirty[1] & /*$$scope*/ 8) {
				image_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				image_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			image.$set(image_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}

			destroy_component(statustracker, detaching);
			destroy_component(image, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(37:0) <Block  {visible}  variant={value === null && source === \\\"upload\\\" ? \\\"dashed\\\" : \\\"solid\\\"}  border_mode={dragging ? \\\"focus\\\" : \\\"base\\\"}  padding={false}  {elem_id}  {elem_classes}  height={height || (source === \\\"webcam\\\" ? undefined : FIXED_HEIGHT)}  {width}  allow_overflow={false}  {container}  {scale}  {min_width} >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				visible: /*visible*/ ctx[4],
				variant: /*value*/ ctx[0] === null && /*source*/ ctx[5] === "upload"
				? "dashed"
				: "solid",
				border_mode: /*dragging*/ ctx[24] ? "focus" : "base",
				padding: false,
				elem_id: /*elem_id*/ ctx[2],
				elem_classes: /*elem_classes*/ ctx[3],
				height: /*height*/ ctx[11] || (/*source*/ ctx[5] === "webcam"
				? undefined
				: FIXED_HEIGHT),
				width: /*width*/ ctx[12],
				allow_overflow: false,
				container: /*container*/ ctx[19],
				scale: /*scale*/ ctx[20],
				min_width: /*min_width*/ ctx[21],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block_1 = {
		c: function create() {
			create_component(block.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const block_changes = {};
			if (dirty[0] & /*visible*/ 16) block_changes.visible = /*visible*/ ctx[4];

			if (dirty[0] & /*value, source*/ 33) block_changes.variant = /*value*/ ctx[0] === null && /*source*/ ctx[5] === "upload"
			? "dashed"
			: "solid";

			if (dirty[0] & /*dragging*/ 16777216) block_changes.border_mode = /*dragging*/ ctx[24] ? "focus" : "base";
			if (dirty[0] & /*elem_id*/ 4) block_changes.elem_id = /*elem_id*/ ctx[2];
			if (dirty[0] & /*elem_classes*/ 8) block_changes.elem_classes = /*elem_classes*/ ctx[3];

			if (dirty[0] & /*height, source*/ 2080) block_changes.height = /*height*/ ctx[11] || (/*source*/ ctx[5] === "webcam"
			? undefined
			: FIXED_HEIGHT);

			if (dirty[0] & /*width*/ 4096) block_changes.width = /*width*/ ctx[12];
			if (dirty[0] & /*container*/ 524288) block_changes.container = /*container*/ ctx[19];
			if (dirty[0] & /*scale*/ 1048576) block_changes.scale = /*scale*/ ctx[20];
			if (dirty[0] & /*min_width*/ 2097152) block_changes.min_width = /*min_width*/ ctx[21];

			if (dirty[0] & /*brush_radius, brush_color, shape, source, tool, selectable, mask_opacity, root, label, show_label, pending, streaming, mirror_webcam, gradio, value, dragging, loading_status*/ 29878243 | dirty[1] & /*$$scope*/ 8) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(block, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block: block_1,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block_1;
}

const FIXED_HEIGHT = 240;

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('InteractiveImage', slots, []);
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = null } = $$props;
	let { source = "upload" } = $$props;
	let { tool = "editor" } = $$props;
	let { label } = $$props;
	let { show_label } = $$props;
	let { streaming } = $$props;
	let { pending } = $$props;
	let { height } = $$props;
	let { width } = $$props;
	let { mirror_webcam } = $$props;
	let { shape } = $$props;
	let { brush_radius } = $$props;
	let { brush_color } = $$props;
	let { mask_opacity } = $$props;
	let { selectable = false } = $$props;
	let { container = true } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { loading_status } = $$props;
	let { root } = $$props;
	let { gradio } = $$props;
	let dragging;

	$$self.$$.on_mount.push(function () {
		if (label === undefined && !('label' in $$props || $$self.$$.bound[$$self.$$.props['label']])) {
			console.warn("<InteractiveImage> was created without expected prop 'label'");
		}

		if (show_label === undefined && !('show_label' in $$props || $$self.$$.bound[$$self.$$.props['show_label']])) {
			console.warn("<InteractiveImage> was created without expected prop 'show_label'");
		}

		if (streaming === undefined && !('streaming' in $$props || $$self.$$.bound[$$self.$$.props['streaming']])) {
			console.warn("<InteractiveImage> was created without expected prop 'streaming'");
		}

		if (pending === undefined && !('pending' in $$props || $$self.$$.bound[$$self.$$.props['pending']])) {
			console.warn("<InteractiveImage> was created without expected prop 'pending'");
		}

		if (height === undefined && !('height' in $$props || $$self.$$.bound[$$self.$$.props['height']])) {
			console.warn("<InteractiveImage> was created without expected prop 'height'");
		}

		if (width === undefined && !('width' in $$props || $$self.$$.bound[$$self.$$.props['width']])) {
			console.warn("<InteractiveImage> was created without expected prop 'width'");
		}

		if (mirror_webcam === undefined && !('mirror_webcam' in $$props || $$self.$$.bound[$$self.$$.props['mirror_webcam']])) {
			console.warn("<InteractiveImage> was created without expected prop 'mirror_webcam'");
		}

		if (shape === undefined && !('shape' in $$props || $$self.$$.bound[$$self.$$.props['shape']])) {
			console.warn("<InteractiveImage> was created without expected prop 'shape'");
		}

		if (brush_radius === undefined && !('brush_radius' in $$props || $$self.$$.bound[$$self.$$.props['brush_radius']])) {
			console.warn("<InteractiveImage> was created without expected prop 'brush_radius'");
		}

		if (brush_color === undefined && !('brush_color' in $$props || $$self.$$.bound[$$self.$$.props['brush_color']])) {
			console.warn("<InteractiveImage> was created without expected prop 'brush_color'");
		}

		if (mask_opacity === undefined && !('mask_opacity' in $$props || $$self.$$.bound[$$self.$$.props['mask_opacity']])) {
			console.warn("<InteractiveImage> was created without expected prop 'mask_opacity'");
		}

		if (loading_status === undefined && !('loading_status' in $$props || $$self.$$.bound[$$self.$$.props['loading_status']])) {
			console.warn("<InteractiveImage> was created without expected prop 'loading_status'");
		}

		if (root === undefined && !('root' in $$props || $$self.$$.bound[$$self.$$.props['root']])) {
			console.warn("<InteractiveImage> was created without expected prop 'root'");
		}

		if (gradio === undefined && !('gradio' in $$props || $$self.$$.bound[$$self.$$.props['gradio']])) {
			console.warn("<InteractiveImage> was created without expected prop 'gradio'");
		}
	});

	const writable_props = [
		'elem_id',
		'elem_classes',
		'visible',
		'value',
		'source',
		'tool',
		'label',
		'show_label',
		'streaming',
		'pending',
		'height',
		'width',
		'mirror_webcam',
		'shape',
		'brush_radius',
		'brush_color',
		'mask_opacity',
		'selectable',
		'container',
		'scale',
		'min_width',
		'loading_status',
		'root',
		'gradio'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InteractiveImage> was created with unknown prop '${key}'`);
	});

	function image_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	const edit_handler = () => gradio.dispatch("edit");
	const clear_handler = () => gradio.dispatch("clear");
	const stream_handler = () => gradio.dispatch("stream");
	const drag_handler = ({ detail }) => $$invalidate(24, dragging = detail);
	const upload_handler = () => gradio.dispatch("upload");
	const select_handler = ({ detail }) => gradio.dispatch("select", detail);
	const share_handler = ({ detail }) => gradio.dispatch("share", detail);

	const error_handler = ({ detail }) => {
		$$invalidate(1, loading_status = loading_status || {});
		$$invalidate(1, loading_status.status = "error", loading_status);
		gradio.dispatch("error", detail);
	};

	$$self.$$set = $$props => {
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(3, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('source' in $$props) $$invalidate(5, source = $$props.source);
		if ('tool' in $$props) $$invalidate(6, tool = $$props.tool);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(8, show_label = $$props.show_label);
		if ('streaming' in $$props) $$invalidate(9, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(10, pending = $$props.pending);
		if ('height' in $$props) $$invalidate(11, height = $$props.height);
		if ('width' in $$props) $$invalidate(12, width = $$props.width);
		if ('mirror_webcam' in $$props) $$invalidate(13, mirror_webcam = $$props.mirror_webcam);
		if ('shape' in $$props) $$invalidate(14, shape = $$props.shape);
		if ('brush_radius' in $$props) $$invalidate(15, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(16, brush_color = $$props.brush_color);
		if ('mask_opacity' in $$props) $$invalidate(17, mask_opacity = $$props.mask_opacity);
		if ('selectable' in $$props) $$invalidate(18, selectable = $$props.selectable);
		if ('container' in $$props) $$invalidate(19, container = $$props.container);
		if ('scale' in $$props) $$invalidate(20, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(21, min_width = $$props.min_width);
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('root' in $$props) $$invalidate(22, root = $$props.root);
		if ('gradio' in $$props) $$invalidate(23, gradio = $$props.gradio);
	};

	$$self.$capture_state = () => ({
		Image: Image_1,
		Block,
		StatusTracker: Static,
		UploadText,
		elem_id,
		elem_classes,
		visible,
		value,
		source,
		tool,
		label,
		show_label,
		streaming,
		pending,
		height,
		width,
		mirror_webcam,
		shape,
		brush_radius,
		brush_color,
		mask_opacity,
		selectable,
		container,
		scale,
		min_width,
		loading_status,
		root,
		gradio,
		dragging,
		FIXED_HEIGHT
	});

	$$self.$inject_state = $$props => {
		if ('elem_id' in $$props) $$invalidate(2, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(3, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(4, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('source' in $$props) $$invalidate(5, source = $$props.source);
		if ('tool' in $$props) $$invalidate(6, tool = $$props.tool);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('show_label' in $$props) $$invalidate(8, show_label = $$props.show_label);
		if ('streaming' in $$props) $$invalidate(9, streaming = $$props.streaming);
		if ('pending' in $$props) $$invalidate(10, pending = $$props.pending);
		if ('height' in $$props) $$invalidate(11, height = $$props.height);
		if ('width' in $$props) $$invalidate(12, width = $$props.width);
		if ('mirror_webcam' in $$props) $$invalidate(13, mirror_webcam = $$props.mirror_webcam);
		if ('shape' in $$props) $$invalidate(14, shape = $$props.shape);
		if ('brush_radius' in $$props) $$invalidate(15, brush_radius = $$props.brush_radius);
		if ('brush_color' in $$props) $$invalidate(16, brush_color = $$props.brush_color);
		if ('mask_opacity' in $$props) $$invalidate(17, mask_opacity = $$props.mask_opacity);
		if ('selectable' in $$props) $$invalidate(18, selectable = $$props.selectable);
		if ('container' in $$props) $$invalidate(19, container = $$props.container);
		if ('scale' in $$props) $$invalidate(20, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(21, min_width = $$props.min_width);
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('root' in $$props) $$invalidate(22, root = $$props.root);
		if ('gradio' in $$props) $$invalidate(23, gradio = $$props.gradio);
		if ('dragging' in $$props) $$invalidate(24, dragging = $$props.dragging);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$$invalidate(0, value = !value ? null : value);
		}

		if ($$self.$$.dirty[0] & /*value, gradio*/ 8388609) {
			(gradio.dispatch("change"));
		}
	};

	return [
		value,
		loading_status,
		elem_id,
		elem_classes,
		visible,
		source,
		tool,
		label,
		show_label,
		streaming,
		pending,
		height,
		width,
		mirror_webcam,
		shape,
		brush_radius,
		brush_color,
		mask_opacity,
		selectable,
		container,
		scale,
		min_width,
		root,
		gradio,
		dragging,
		image_value_binding,
		edit_handler,
		clear_handler,
		stream_handler,
		drag_handler,
		upload_handler,
		select_handler,
		share_handler,
		error_handler
	];
}

class InteractiveImage extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				elem_id: 2,
				elem_classes: 3,
				visible: 4,
				value: 0,
				source: 5,
				tool: 6,
				label: 7,
				show_label: 8,
				streaming: 9,
				pending: 10,
				height: 11,
				width: 12,
				mirror_webcam: 13,
				shape: 14,
				brush_radius: 15,
				brush_color: 16,
				mask_opacity: 17,
				selectable: 18,
				container: 19,
				scale: 20,
				min_width: 21,
				loading_status: 1,
				root: 22,
				gradio: 23
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InteractiveImage",
			options,
			id: create_fragment.name
		});
	}

	get elem_id() {
		return this.$$.ctx[2];
	}

	set elem_id(elem_id) {
		this.$$set({ elem_id });
		flush();
	}

	get elem_classes() {
		return this.$$.ctx[3];
	}

	set elem_classes(elem_classes) {
		this.$$set({ elem_classes });
		flush();
	}

	get visible() {
		return this.$$.ctx[4];
	}

	set visible(visible) {
		this.$$set({ visible });
		flush();
	}

	get value() {
		return this.$$.ctx[0];
	}

	set value(value) {
		this.$$set({ value });
		flush();
	}

	get source() {
		return this.$$.ctx[5];
	}

	set source(source) {
		this.$$set({ source });
		flush();
	}

	get tool() {
		return this.$$.ctx[6];
	}

	set tool(tool) {
		this.$$set({ tool });
		flush();
	}

	get label() {
		return this.$$.ctx[7];
	}

	set label(label) {
		this.$$set({ label });
		flush();
	}

	get show_label() {
		return this.$$.ctx[8];
	}

	set show_label(show_label) {
		this.$$set({ show_label });
		flush();
	}

	get streaming() {
		return this.$$.ctx[9];
	}

	set streaming(streaming) {
		this.$$set({ streaming });
		flush();
	}

	get pending() {
		return this.$$.ctx[10];
	}

	set pending(pending) {
		this.$$set({ pending });
		flush();
	}

	get height() {
		return this.$$.ctx[11];
	}

	set height(height) {
		this.$$set({ height });
		flush();
	}

	get width() {
		return this.$$.ctx[12];
	}

	set width(width) {
		this.$$set({ width });
		flush();
	}

	get mirror_webcam() {
		return this.$$.ctx[13];
	}

	set mirror_webcam(mirror_webcam) {
		this.$$set({ mirror_webcam });
		flush();
	}

	get shape() {
		return this.$$.ctx[14];
	}

	set shape(shape) {
		this.$$set({ shape });
		flush();
	}

	get brush_radius() {
		return this.$$.ctx[15];
	}

	set brush_radius(brush_radius) {
		this.$$set({ brush_radius });
		flush();
	}

	get brush_color() {
		return this.$$.ctx[16];
	}

	set brush_color(brush_color) {
		this.$$set({ brush_color });
		flush();
	}

	get mask_opacity() {
		return this.$$.ctx[17];
	}

	set mask_opacity(mask_opacity) {
		this.$$set({ mask_opacity });
		flush();
	}

	get selectable() {
		return this.$$.ctx[18];
	}

	set selectable(selectable) {
		this.$$set({ selectable });
		flush();
	}

	get container() {
		return this.$$.ctx[19];
	}

	set container(container) {
		this.$$set({ container });
		flush();
	}

	get scale() {
		return this.$$.ctx[20];
	}

	set scale(scale) {
		this.$$set({ scale });
		flush();
	}

	get min_width() {
		return this.$$.ctx[21];
	}

	set min_width(min_width) {
		this.$$set({ min_width });
		flush();
	}

	get loading_status() {
		return this.$$.ctx[1];
	}

	set loading_status(loading_status) {
		this.$$set({ loading_status });
		flush();
	}

	get root() {
		return this.$$.ctx[22];
	}

	set root(root) {
		this.$$set({ root });
		flush();
	}

	get gradio() {
		return this.$$.ctx[23];
	}

	set gradio(gradio) {
		this.$$set({ gradio });
		flush();
	}
}

const InteractiveImage$1 = InteractiveImage;

export { InteractiveImage$1 as I, Webcam$1 as W };
//# sourceMappingURL=InteractiveImage-76ed3311.js.map
